/*
 * EnumerateMaximalCliques.java
 *
 * Created on 15 October 2007, 13:25
 *
 * Copyright Daniel McEnnis, published under Aferro GPL (see license.txt)
 */
/*
 *   This file is part of GraphRAT.
 *
 *   GraphRAT is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   GraphRAT is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with GraphRAT.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.mcennis.graphrat.algorithm.clustering;

import java.util.Arrays;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.mcennis.graphrat.algorithm.Algorithm;
import org.mcennis.graphrat.algorithm.AlgorithmMacros;
import org.mcennis.graphrat.graph.Clique;

import org.mcennis.graphrat.graph.Graph;
import org.dynamicfactory.descriptors.*;

import org.mcennis.graphrat.actor.Actor;
import org.mcennis.graphrat.descriptors.IODescriptor;


import org.mcennis.graphrat.descriptors.IODescriptor.Type;
import org.mcennis.graphrat.descriptors.IODescriptorFactory;

import org.dynamicfactory.model.ModelShell;
import org.mcennis.graphrat.query.ActorQuery;
import org.mcennis.graphrat.query.ActorQueryFactory;
import org.mcennis.graphrat.query.LinkQuery;
import org.mcennis.graphrat.query.LinkQueryFactory;
import org.mcennis.graphrat.query.actor.ActorByMode;
import org.mcennis.graphrat.query.link.LinkByRelation;
import org.mcennis.graphrat.scheduler.Scheduler;

/**
 * Maximal cliques are defined as a fully connected subgraph such that any 
 * additional node added to the subgraph is not fully connected.
 *
 * This problem is NP-Complete, but can be completed in O(nlog(n)) where n is the 
 * number of nodes in the graph and exponential over k where k is the maximum 
 * out degree of the graph. For many applications, including web page hyperlink 
 * structure and social network data, k is suffeciantly small that the 
 * algorithm's cost is manageable.
 *
 * This a rediscovery of the Bron-Berbosch Algorithm (1973)
 * C. Bron, J. Kerboach, Algorithm 457. 1973. Finding all cliques of an uncirected graph.
 * <i>Communications of the ACM</i>. 16(9):575-577.
 * 
 * @author Daniel McEnnis
 *
 */
public class EnumerateMaximalCliques extends ModelShell implements Algorithm {

    /**
     * set of candidate maximal cliques including the seed node
     */
    HashSet<Clique> maximal = new HashSet<Clique>();
    /**
     * set of all maximal cliques confirmed to date
     */
    HashSet<Clique> globalMaximal = new HashSet<Clique>();
    /**
     * All current cliques generated by breadth first search of new maximal
     * clique candidates from a given seed node for a given clique size
     */
    HashSet<Clique> currentLevel = new HashSet<Clique>();
    /**
     * all potential maximal clique candidates generated in the previous step
     * all cliques in this set are of the same size.
     */
    HashSet<Clique> lastLevel = new HashSet<Clique>();
    /**
     * Generates a unique clique name based on the order that the clique is 
     * discovered.
     */
    int cliqueCount = 0;
    /**
     * Description of all parameters that modify how this algorithm interacts 
     * with other algorithms.  Used to automate parameter setting
     */
    PropertiesInternal parameter = PropertiesFactory.newInstance().create();
    /**
     * Formal description of all algorithmic inputs used by this algorithm. This
     * algorithm requires a link type as input. (Type is specified in paramters)
     */
    LinkedList<IODescriptor> input = new LinkedList<IODescriptor>();
    /**
     * Formal description of all algorithmic outputs.  This algorithm generates 
     * one property on actors of a given relation. (Specified in parameter 
     * settings)
     */
    LinkedList<IODescriptor> output = new LinkedList<IODescriptor>();

    /** Creates a new instance of EnumerateMaximalCliques */
    public EnumerateMaximalCliques() {
        ParameterInternal name = ParameterFactory.newInstance().create("AlgorithmClass", String.class);
        SyntaxObject syntax = SyntaxCheckerFactory.newInstance().create(1, 1, null, String.class);
        name.setRestrictions(syntax);
        name.add("Bicomponent Clusterer");
        parameter.add(name);

        name = ParameterFactory.newInstance().create("Name", String.class);
        syntax = SyntaxCheckerFactory.newInstance().create(1, Integer.MAX_VALUE, null, String.class);
        name.setRestrictions(syntax);
        name.add("Bicomponent Clusterer");
        parameter.add(name);

        name = ParameterFactory.newInstance().create("Category", String.class);
        syntax = SyntaxCheckerFactory.newInstance().create(1, 1, null, String.class);
        name.setRestrictions(syntax);
        name.add("Clustering");
        parameter.add(name);

        name = ParameterFactory.newInstance().create("LinkFilter", LinkQuery.class);
        syntax = SyntaxCheckerFactory.newInstance().create(0, 1, null, LinkQuery.class);
        name.setRestrictions(syntax);
        parameter.add(name);

        name = ParameterFactory.newInstance().create("ActorFilter", ActorQuery.class);
        syntax = SyntaxCheckerFactory.newInstance().create(0, 1, null, ActorQuery.class);
        name.setRestrictions(syntax);
        parameter.add(name);

        name = ParameterFactory.newInstance().create("SourceAppendGraphID", Boolean.class);
        syntax = SyntaxCheckerFactory.newInstance().create(1, 1, null, Boolean.class);
        name.setRestrictions(syntax);
        name.add(false);
        parameter.add(name);

        name = ParameterFactory.newInstance().create("Mode", String.class);
        syntax = SyntaxCheckerFactory.newInstance().create(1, 1, null, String.class);
        name.setRestrictions(syntax);
        name.add("tag");
        parameter.add(name);

        name = ParameterFactory.newInstance().create("Relation", String.class);
        syntax = SyntaxCheckerFactory.newInstance().create(1, 1, null, String.class);
        name.setRestrictions(syntax);
        name.add("tag");
        parameter.add(name);

        name = ParameterFactory.newInstance().create("LinkQuery", LinkQuery.class);
        syntax = SyntaxCheckerFactory.newInstance().create(1, 1, null, LinkQuery.class);
        name.setRestrictions(syntax);
        parameter.add(name);

        name = ParameterFactory.newInstance().create("SourceProperty", String.class);
        syntax = SyntaxCheckerFactory.newInstance().create(1, 1, null, String.class);
        name.setRestrictions(syntax);
        name.add("Property");
        parameter.add(name);

        name = ParameterFactory.newInstance().create("DestinationProperty", String.class);
        syntax = SyntaxCheckerFactory.newInstance().create(1, 1, null, String.class);
        name.setRestrictions(syntax);
        name.add("Property");
        parameter.add(name);

        name = ParameterFactory.newInstance().create("GraphIDPrefix", String.class);
        syntax = SyntaxCheckerFactory.newInstance().create(1, 1, null, String.class);
        name.setRestrictions(syntax);
        name.add("Property");
        parameter.add(name);

        name = ParameterFactory.newInstance().create("AddContext", Boolean.class);
        syntax = SyntaxCheckerFactory.newInstance().create(1, 1, null, Boolean.class);
        name.setRestrictions(syntax);
        name.add(false);
        parameter.add(name);
    }

    public void execute(Graph g) {
        ActorByMode mode = (ActorByMode)ActorQueryFactory.newInstance().create("ActorByMode");
        mode.buildQuery((String)parameter.get("Mode").get(),".*",false);

        LinkByRelation relation = (LinkByRelation)LinkQueryFactory.newInstance().create("LinkByRelation");
        relation.buildQuery((String)parameter.get("Relation").get(),false);

        /*
         * Start with every actor as a seed clqiue of one
         */
        Vector<Actor> allActors = new Vector<Actor>();
        allActors.addAll(AlgorithmMacros.filterActor(parameter, g, mode.execute(g, null, null)));

        /**
         * Sort ther actor array, giving an actor ranking
         */
        Collections.sort(allActors);

        int maxClique = 0;

        fireChange(Scheduler.SET_ALGORITHM_COUNT,allActors.size());
        /**
         * Grow cliques using each actor as a seed node
         */
        for (int i = 0; i < allActors.size(); ++i) {

            currentLevel.clear();

            lastLevel.clear();

            maximal.clear();



            int level = 0;

            Clique base = new Clique();

            g.addChild(base);

            base.setID((String) parameter.get("GraphIDPrefix").get() + cliqueCount);

            base.setActorType((String) parameter.get("Mode").get());

            base.setRelation((String) parameter.get("Relation").get());

            base.add(allActors.get(i));

            if(parameter.get("LinkFilter").getValue().size()>0){
                base.getParameter().add("LinkFilter", parameter.get("LinkFilter").get());
            }

            lastLevel.add(base);

            cliqueCount++;



            /**
             * Continue iterating over cliques of increasing size until no 
             * greater cliques are found.  This is bounded by the out degree of 
             * the seed node.  WARNING this can blow up computationally for 
             * seeds with massive out degrees (out degree ~= # nodes).
             */
            while (lastLevel.size() > 0) {

                level++;

                Iterator<Clique> itLastLevel = lastLevel.iterator();

                while (itLastLevel.hasNext()) {

                    Clique seed = itLastLevel.next();

                    Collection<Actor> intersection = seed.getIntersection();

                    if (intersection.size()>0) {

                        /**
                         * add all new cliques (see helper)
                         */
                        extend(seed, intersection.toArray(new Actor[]{}));

                    }

                }

                lastLevel = currentLevel;

                currentLevel = new HashSet<Clique>();

            }

            /**
             * By only allowing checking of cliqies with only higher actors,
             * some non-maximal cliques are included as well
             */
            assertMaximal(maximal);



            /**
             * Take all maximal cliques and add them to the set of all cliques
             */
            globalMaximal.addAll(maximal);

            if ((level - 1) > maxClique) {

                maxClique = level - 1;

            }
            fireChange(Scheduler.SET_ALGORITHM_PROGRESS,i);
        }

        Logger.getLogger(EnumerateMaximalCliques.class.getName()).log(Level.FINE, "Maximal Clique count = " + globalMaximal.size());

        Logger.getLogger(EnumerateMaximalCliques.class.getName()).log(Level.FINE, "Max Clique Size " + maxClique);

        Iterator<Clique> itGlobalMaximal = globalMaximal.iterator();

        while (itGlobalMaximal.hasNext()) {

            Clique next = itGlobalMaximal.next();

            g.addChild(next.transform());

        }

        maximal.clear();

        allActors = null;

        currentLevel.clear();

        lastLevel.clear();

    }

    /**
     * create a set of new cliques of size n+1 from a clique of size n.  This 
     * only need to be done for actors strictly greater than the largest actor 
     * in the set.  This is acceptable since every clique involving a smaller 
     * actor will already generate this clique in a previous iteration.  
     * However, this generates some spurious maximal cliques that are subsets
     * of other cliques.  These are weeded out by assertMaximal algorithm
     */
    protected void extend(Clique seed, Actor[] intersection) {

        Arrays.sort(intersection);

        Actor largest = seed.getMaxActor();

        for (int i = 0; i < intersection.length; ++i) {

            if (intersection[i].compareTo(largest) > 0) {

                Clique next = seed.expand(intersection[i]);

                if (next != null) {

                    next.setID((String) parameter.get("GraphIDPrefix").get() + cliqueCount);

                    cliqueCount++;

                    currentLevel.add(next);

                    maximal.remove(seed);

                    maximal.add(next);

                }

            }

        }

    }

    /**
     * This functions identify those cliques that are subsets of maixmal cliques
     * rather than maximal cliques themselves.  These are removed from the set 
     * of maximal cliques before they are added to the global clique set.  The 
     * test is to sequentially test whether or not there exists a node in the 
     * intersection that creates a new clique (hence the current clique is not 
     * maximal).  Since this clique will be created by another clique or seed,
     * this clique can be safely discarded.
     */
    protected void assertMaximal(HashSet<Clique> maximal) {

        Clique[] maximalArray = maximal.toArray(new Clique[]{});

        for (int i = 0; i < maximalArray.length; ++i) {

            Collection<Actor> intersection = maximalArray[i].getIntersection();

            if (intersection.size()>0) {
                Iterator<Actor> intersectionIt = intersection.iterator();
                while (intersectionIt.hasNext()) {

                    if (maximalArray[i].expand(intersectionIt.next()) != null) {

                        maximal.remove(maximalArray[i]);

                        break;

                    }

                }

            }

        }

    }

    @Override
    public List<IODescriptor> getInputType() {

        return input;

    }

    @Override
    public List<IODescriptor> getOutputType() {

        return output;

    }

    @Override
    public Properties getParameter() {

        return parameter;

    }

    @Override
    public Parameter getParameter(String param) {
        return parameter.get(param);

    }

    /**
     * Parameters for init:
     * <ol>
     * <li>'name' - name for this instance of the algorithm. Default 'Enumerate Maximal Cliques'.
     * <li>'relation' - name of the type (relation) of link to be used. Default
     * 'Knows'.
     * <li>'actorType' - naem of the actor type (mode) to be used. Default 'User'.
     * <li>'graphIDPrefix' - name of the prefix for the ids  of generated graphs.
     * Default 'clique'.
     * </ol>
     * <br>
     * <br>Input  1 - Link
     * <br>Output 1 - Graph
     */
    public void init(Properties map) {
        if(parameter.check(map)){
            parameter.merge(map);

            IODescriptor desc = IODescriptorFactory.newInstance().create(
                    Type.ACTOR,
                    (String)parameter.get("Name").get(),
                    (String)parameter.get("Mode").get(),
                    null,
                    null,
                    "",
                    false);
            input.add(desc);

            desc = IODescriptorFactory.newInstance().create(
                    Type.LINK,
                    (String)parameter.get("Name").get(),
                    (String)parameter.get("Relation").get(),
                    null,
                    null,
                    "",
                    false);
            input.add(desc);

            desc = IODescriptorFactory.newInstance().create(
                    Type.GRAPH,
                    (String)parameter.get("Name").get(),
                    (String)parameter.get("GraphIDPrefix").get(),
                    null,
                    null,
                    "",
                    true);
            output.add(desc);
        }
    }

    public EnumerateMaximalCliques prototype(){
        return new EnumerateMaximalCliques();
    }
}

