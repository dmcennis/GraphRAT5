/*

 * 

 * Copyright Daniel McEnnis - see license.txt

 */

/*
 *   This file is part of GraphRAT.
 *
 *   GraphRAT is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   GraphRAT is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with GraphRAT.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.mcennis.graphrat.parser;



import java.io.InputStream;

import java.io.InputStreamReader;

import java.io.LineNumberReader;

import java.net.URL;

import java.util.HashMap;

import java.util.Iterator;

import java.util.regex.Matcher;

import java.util.regex.Pattern;

import org.dynamicfactory.property.Property;
import org.dynamicfactory.property.PropertyFactory;

import org.mcennis.graphrat.crawler.Crawler;

import org.mcennis.graphrat.graph.Graph;

import org.mcennis.graphrat.actor.Actor;

import org.mcennis.graphrat.actor.ActorFactory;

import org.mcennis.graphrat.link.Link;

import org.mcennis.graphrat.link.LinkFactory;


/**

 * This class parses bibtex files generated by a custom group of perl scripts 

 * that take as input the comma seperated files from www.ismir.net, then reads 

 * the xml version of the papers (pdftohtml) to determine which ismir papers 

 * reference which other papers.  These documents have a strict format which 

 * makes for easy parsing.  In particular, unlike traditional bibtex, these 

 * files have a specific order of fields as well as the non-standard fields of 

 * references and file.  IDs are assumed to be integers (not standard), all 

 * fields are encased in double quotes that extend for a single line, and 

 * references are a set of integers seperated by commas.  This script loads this 

 * format into RAT and establishes two modes (types) of actors: Author and 

 * Paper.  There are two relations (kinds) of link: References (Paper to Paper) 

 * and AuthorOf (Author to Paper).  

 *

 * @author Daniel McEnnis

 * 

 */

public class ISMIRBibtexParser extends AbstractParser {



    Graph graph = null;

    String id = "ISMIRBibtexParser";

    

    public ISMIRBibtexParser(){

        super();

        properties.get("Name").add("ISMIRBibtexParser");

        properties.get("ParserClass").add("ISMIRBibtexParser");

    }

    /**

     * Parse the modified bibtex file.  The file is modified in that an ordering

     * of the fields is assumed, all listed fields are assumed to be present 

     * (numeric id as identifier, followed by 

     * @param data

     * @throws Exception

     */



    public void parse(InputStream data,String site) throws Exception {

        HashMap<Integer, Actor> actors = new HashMap<Integer, Actor>();

        HashMap<Integer, int[]> references = new HashMap<Integer, int[]>();

        Pattern articleP = Pattern.compile("@Article\\{(.*),");

        Pattern authorP = Pattern.compile("author = \"(.*)\",");

        Pattern titleP = Pattern.compile("title = \"(.*)\",");

        Pattern referenceP = Pattern.compile("references = \"(.*)\",");

        Pattern fileP = Pattern.compile("file = \"(.*)\",");

        Pattern typeP = Pattern.compile("type = \"(.*)\",");

        Matcher articleM;

        Matcher authorM;

        Matcher titleM;

        Matcher referenceM;

        Matcher fileM;

        Matcher typeM;

        int id = -1;

        String authorString = "";

        Actor[] authors = null;

        Actor paper = null;



        /*

         * Read every line and parse each bibtex entry.  If fields are not in 

         * the proper order, this system will crash and burn.

         */

        LineNumberReader reader = new LineNumberReader(new InputStreamReader(data));

        String line = reader.readLine();

        while (line != null) {

            articleM = articleP.matcher(line);

            authorM = authorP.matcher(line);

            titleM = titleP.matcher(line);

            referenceM = referenceP.matcher(line);

            fileM = fileP.matcher(line);

            typeM = typeP.matcher(line);



            /*

             *  if this is the opening line of an entry (containing the numeric 

             *  id), parse it, storing the id to be used for the rest of the 

             *  entries.

             */

            if (articleM.matches()) {

                id = Integer.parseInt(articleM.group(1));

            /*

             * if this is the author line, split the authors.  The format is 

             * is specified as the author line in the ismir CSV format.  Authors

             * are in inverse order, first and last name, seperated by semicolons

             * surrounded by white space.  This block seperates out the authors

             * and creates new Author actors for each, adding to the graph and 

             * alsdo storing in an array of actors for later adding to the paper

             * object this bibtex enrty represents. 

             */

            } else if (authorM.matches()) {

                authorString = authorM.group(1);

                String[] authorNames = Pattern.compile("\\s*;\\s*").split(authorString);

                authors = new Actor[authorNames.length];

                for (int i = 0; i < authorNames.length; ++i) {

                    Actor author = graph.getActor("Author", authorNames[i]);

                    if (author == null) {

                        author = ActorFactory.newInstance().create("Author",authorNames[i]);

                        graph.add(author);

                    }

                    authors[i] = author;

                }

            /*

             * Title is taken verbatim from inside the quotes.  Title is used as

             * the unique id for a Paper actor which is added to the graph.  The

             * actor array (assumed to exist) is then utilized to create the 

             * links between the authors and this paper they authored. 

             */

            } else if (titleM.matches()) {

                paper = ActorFactory.newInstance().create("Paper",titleM.group(1));

                graph.add(paper);

                actors.put(id, paper);

                for (int i = 0; i < authors.length; ++i) {

                    Link authorOf = LinkFactory.newInstance().create("AuthorOf");

                    authorOf.set(authors[i], 1.0, paper);

                    graph.add(authorOf);

                }

                authors = null;

            /*

             * Since many are forward references, this creates a new int[] that

             * contains the contents of the references line for later processing

             */

            } else if (referenceM.matches()) {

                String values = referenceM.group(1);

                int[] ref = new int[]

                   

                   {};

                String[] referencesString = Pattern.compile(",").split(values);

                if ((referencesString != null) && (referencesString.length > 0) && (!referencesString[0].contentEquals(""))) {

                    ref = new int[referencesString.length];

                    for (int i = 0; i < referencesString.length; ++i) {

                        ref[i] = Integer.parseInt(referencesString[i]);

                    }

                    references.put(id, ref);

                }



            /*

             * This is the remote location of the file the Paper object is 

             * representing, stored as a page object for future analysis.

             */

            } else if (fileM.matches()) {

                URL url = new URL(fileM.group(1));

                Property file = PropertyFactory.newInstance().create("BasicProperty","FileLocation",URL.class);

                file.add(url);

                paper.add(file);

            /*

             * This is the class of paper - a property of the Paper actor.

             */

            } else if (typeM.matches()) {

                Property property = PropertyFactory.newInstance().create("BasicProperty","Type",String.class);

                property.add(typeM.group(1));

                paper.add(property);

            }

            line = reader.readLine();

        }// while(line != null)



        /*

         * Now that all the papers have been created, link the papers by their 

         * references.   

         */

        Iterator<Integer> it = references.keySet().iterator();

        while (it.hasNext()) {

            int sourceID = it.next();

            int[] refList = references.get(sourceID);

            for (int i = 0; i <

                    refList.length; ++i) {

                Link refLink = LinkFactory.newInstance().create("Reference");

                Actor source = actors.get(sourceID);

                if(source == null){

                    System.err.println("Source "+sourceID+" does not exist");

                }

                Actor dest = actors.get(refList[i]);

                if(dest == null){

                    System.err.println("Dest "+refList[i]+" does not exist");

                }

                refLink.set(source, 1.0, dest);

                graph.add(refLink);

            }



        }

    }



    /**

     * Identical to parse - no spidering is done

     * @param data data to be parsed

     * @param crawler ignored

     * @throws Exception

     */

    public void parse(InputStream data, Crawler crawler, String site) throws Exception {

        parse(data,site);

    }



    @Override

    public Parser duplicate() {

        ISMIRBibtexParser ret = new ISMIRBibtexParser();

        ret.graph = graph;

        ret.properties = this.properties.duplicate();

        return ret;

    }



    @Override

    public ParsedObject get() {

        return graph;

    }



    @Override

    public void set(ParsedObject o) {

        if (o instanceof Graph) {

            graph = (Graph) o;

        }

    }



}

