/* * HITSPrestige.java * * Created on 19 October 2007, 13:46 * * Copyright Daniel McEnnis, published under Aferro GPL (see license.txt) */package org.mcennis.graphrat.algorithm.prestige;import cern.colt.matrix.DoubleFactory2D;import cern.colt.matrix.DoubleMatrix1D;import cern.colt.matrix.DoubleMatrix2D;import cern.colt.matrix.linalg.EigenvalueDecomposition;import java.util.Properties;import java.util.logging.Level;import java.util.logging.Logger;import org.mcennis.graphrat.algorithm.Algorithm;import org.mcennis.graphrat.graph.Graph;import org.mcennis.graphrat.actor.Actor;import org.dynamicfactory.descriptors.DescriptorFactory;import org.dynamicfactory.descriptors.InputDescriptor;import org.dynamicfactory.descriptors.InputDescriptorInternal;import org.dynamicfactory.descriptors.OutputDescriptor;import org.dynamicfactory.descriptors.OutputDescriptorInternal;import org.dynamicfactory.descriptors.SettableParameter;import org.mcennis.graphrat.link.Link;import org.dynamicfactory.model.ModelShell;import org.mcennis.graphrat.scheduler.Scheduler;/** * Class implementing a naive implementation of Kelinberg's HITS algorithm (Kleinberg99) * <br> * <br>Kleinberg, J. 1999. "Authoritative sources in a hyperlinked environment."  * <i>Journal of the ACM</i>. 46(5):604--32. * * @author Daniel McEnnis *  */public class HITSPrestige extends ModelShell implements Algorithm {    ParameterInternal[] parameter = new ParameterInternal[5];    InputDescriptorInternal[] input = new InputDescriptorInternal[1];    OutputDescriptorInternal[] output = new OutputDescriptorInternal[2];    /** Creates a new instance of HITSPrestige */    public HITSPrestige() {    }    /**     * Implements the HITS algorithm by directly calculating the eigenvector matrix     * using Colt's matrix operators.  This is O(n2) in space.  Creates a Hub and      * Authority score for each actor.     *      */    public void execute(Graph g) {        try {            fireChange(Scheduler.SET_ALGORITHM_COUNT,3);            Actor[] a = g.getActor((String) parameter[2].getValue());            java.util.Arrays.sort(a);            DoubleMatrix2D links = DoubleFactory2D.sparse.make(a.length + 1, a.length + 1);            links.assign(0.0);//        Link[] l = g.getLink((String)parameter[2].getValue());//        for(int i=0;i<l.length;++i){//            int source = java.util.Arrays.binarySearch(a,l[i].getSource());//            links.set(source,dest,0.15);//        }            for (int i = 0; i < a.length; ++i) {                Link[] l = g.getLinkBySource((String) parameter[1].getValue(), a[i]);                if (l != null) {                    for (int j = 0; j < l.length; ++j) {                        int dest = java.util.Arrays.binarySearch(a, l[j].getDestination());                        links.set(i, dest, (1.0 - ((Double) parameter[4].getValue()).doubleValue()) / ((double) l.length));                    }                } else {                    Logger.getLogger(HITSPrestige.class.getName()).log(Level.WARNING, "User " + a[i].getID() + " has no outgoing links");                }            }            for (int i = 0; i < links.columns(); ++i) {                links.set(i, a.length, ((Double) parameter[4].getValue()).doubleValue());                links.set(a.length, i, 1.0 / ((double) a.length));            }            DoubleMatrix2D hubs = DoubleFactory2D.dense.make(a.length + 1, a.length + 1);            hubs.assign(0.0);            DoubleMatrix2D authorities = DoubleFactory2D.dense.make(a.length + 1, a.length + 1);            authorities.assign(0.0);            links.zMult(links, hubs, 1.0, 0.0, true, false);            links.zMult(links, authorities, 1.0, 0.0, false, true);            fireChange(Scheduler.SET_ALGORITHM_PROGRESS,1);            EigenvalueDecomposition hubsEigen = new EigenvalueDecomposition(hubs);            DoubleMatrix1D hubEigenVector = hubsEigen.getV().viewColumn(0);            if (hubEigenVector.get(0) < 0.0) {                for (int i = 0; i < hubEigenVector.size(); ++i) {                    hubEigenVector.setQuick(i, -1.0 * hubEigenVector.getQuick(i));                }            }            hubsEigen = null;            fireChange(Scheduler.SET_ALGORITHM_PROGRESS,2);            EigenvalueDecomposition authoritiesEigen = new EigenvalueDecomposition(authorities);            DoubleMatrix1D authoritiesEigenVector = authoritiesEigen.getV().viewColumn(0);            authoritiesEigen = null;            if (authoritiesEigenVector.get(0) < 0.0) {                for (int i = 0; i < authoritiesEigenVector.size(); ++i) {                    authoritiesEigenVector.setQuick(i, -1.0 * authoritiesEigenVector.getQuick(i));                }            }            // normalize the results to length 1            cern.colt.matrix.linalg.Algebra base = new cern.colt.matrix.linalg.Algebra();            double norm = base.norm2(hubEigenVector);            for (int i = 0; i < hubEigenVector.size(); ++i) {                hubEigenVector.set(i, hubEigenVector.get(i) / Math.sqrt(norm));            }            norm = base.norm2(authoritiesEigenVector);            for (int i = 0; i < authoritiesEigenVector.size(); ++i) {                authoritiesEigenVector.set(i, authoritiesEigenVector.get(i) / Math.sqrt(norm));            }            Properties props = new Properties();            props.setProperty("PropertyClass", "java.lang.Double");            for (int i = 0; i < a.length; ++i) {                props.setProperty("PropertyID", output[0].getProperty());                Property property = PropertyFactory.newInstance().create(props);                property.add(new Double(hubEigenVector.get(i)));                a[i].add(property);                props.setProperty("PropertyID", output[1].getProperty());                property = PropertyFactory.newInstance().create(props);                property.add(new Double(authoritiesEigenVector.get(i)));                a[i].add(property);            }        } catch (InvalidObjectTypeException ex) {            Logger.getLogger(HITSPrestige.class.getName()).log(Level.SEVERE, "Property class of "+output[1].getProperty()+" does not match java.lang.Double", ex);        }    }    @Override    public InputDescriptor[] getInputType() {        return input;    }    @Override    public OutputDescriptor[] getOutputType() {        return output;    }    @Override    public Parameter[] getParameter() {        return parameter;    }    @Override    public Parameter getParameter(String param) {        for (int i = 0; i < parameter.length; ++i) {            if (parameter[i].getName().contentEquals(param)) {                return parameter[i];            }        }        return null;    }    @Override    public SettableParameter[] getSettableParameter() {        return new SettableParameter[]{parameter[4]};    }    @Override    public SettableParameter getSettableParameter(String param) {        if (parameter[4].getName().equals(param)) {            return parameter[4];        } else {            return null;        }    }    /**     * Parameters to be initialized     *      * <ol>     * <li>'name' - Name of this instance of the algorithm. Default is 'HITS Centrality'.     * <li>'relation' - name of the type (relation) of link to calculate over.      * Default is 'Knows'.     * <li>'actorSourceType' - type (mode) of actor to calculate over.  Default 'User'.     * <li>'propertyNamePrefix' - name of the property prefic to use when listing      * algorithm output.  Deafult 'Knows HITS'.     * </ol>     * <br>     * <br>Input 0 - Link     * <br>Output 0 - Actor Property     * <br>Output 1 - Actor Property     */    public void init(Properties map) {        Properties props = new Properties();        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "name");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[0] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("name") != null)) {            parameter[0].setValue(map.getProperty("name"));        } else {            parameter[0].setValue("HITS Centrality");        }        // Parameter 1 - relation        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "relation");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[1] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("relation") != null)) {            parameter[1].setValue(map.getProperty("relation"));        } else {            parameter[1].setValue("Knows");        }        // Parameter 2 - actor source type        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "actorSourceType");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[2] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("actorSourceType") != null)) {            parameter[2].setValue(map.getProperty("actorSourceType"));        } else {            parameter[2].setValue("User");        }        // Parameter 3 - actor relation        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "propertyNamePrefix");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[3] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("propertyNamePrefix") != null)) {            parameter[3].setValue(map.getProperty("propertyNamePrefix"));        } else {            parameter[3].setValue("Knows HITS");        }        // Parameter 4 - teleportation factor        props.setProperty("Type", "java.lang.Double");        props.setProperty("Name", "teleportationFactor");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[4] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("teleportationFactor") != null)) {            parameter[4].setValue(new Double(Double.parseDouble(map.getProperty("teleportationFactor"))));        } else {            parameter[4].setValue(new Double(0.15));        }        // input 0        props.setProperty("Type", "Link");        props.setProperty("Relation", (String) parameter[1].getValue());        props.setProperty("AlgorithmName", (String) parameter[0].getValue());        props.remove("Property");        input[0] = DescriptorFactory.newInstance().createInputDescriptor(props);        // output 0        props.setProperty("Type", "ActorProperty");        props.setProperty("Relation", (String) parameter[2].getValue());        props.setProperty("AlgorithmName", (String) parameter[0].getValue());        props.setProperty("Property", (String) parameter[3].getValue() + " Hub Score");        output[0] = DescriptorFactory.newInstance().createOutputDescriptor(props);        // output 1        props.setProperty("Type", "ActorProperty");        props.setProperty("Relation", (String) parameter[2].getValue());        props.setProperty("AlgorithmName", (String) parameter[0].getValue());        props.setProperty("Property", (String) parameter[3].getValue() + " Authority Score");        output[1] = DescriptorFactory.newInstance().createOutputDescriptor(props);    }}