/* * DescriptorFactory.java * * Created on 14 September 2007, 13:58 * * Copyright Daniel McEnnis, published under Aferro GPL (see license.txt) */package nz.ac.waikato.mcennis.rat.graph.descriptors;/** * *  * Class for generating descriptors from a Properties map.  * @author Daniel McEnnis */public class DescriptorFactory {        private static DescriptorFactory instance = null;        /**     * Create a new reference to a singelton DescriptorFactory object     *      * @return reference to the Factory.     */    public static DescriptorFactory newInstance(){        if(instance == null){            instance = new DescriptorFactory();        }        return instance;    }        /** Creates a new instance of DescriptorFactory */    private DescriptorFactory() {    }        /**     * Creates a new Parameter object.     *      * The type of parameter is chosen via the key 'Class'     * <ul>     * <li>'Basic' - BasicParameter     * <li>'Exponential' - ExponentialDecayParameter     * <li>'Average' - AverageSumParameter     * </ul>     *      * All parameters take the same additional optional parameters     * <ul>     * <li>'Name' - sets the name of the parameter     * <li>'Structural' - sets whether the parameter is structurla or not     * <li>'Type' - sets the class of this parameter. Reports an error and leaves     * at the default value if the class is not present in the JVM     * </ul>      *      * @param props map of parameters for creating the Object     * @return the newly created parameter object.      */    public ParameterInternal createParameter(java.util.Properties props){        ParameterInternal ret = null;        if(props == null){            System.err.println("DescriptorFactory: WARNING-properties is null, using defaults");            return new BasicParameter();        }else if(props.getProperty("Class").contentEquals("Basic")){            ret = new BasicParameter();        }else if(props.getProperty("Class").contentEquals("Exponential")){            ret = new ExponentialDecayParameter();        }else if(props.getProperty("Class").contentEquals("Average")){            ret = new AverageSumParameter();        }else{            ret = new BasicParameter();            System.err.println("ERROR: Unknown Parameter class '"+props.getProperty("Class")+"'");        }        if(props.getProperty("Name") != null){            ret.setName(props.getProperty("Name"));        }        if(props.getProperty("Structural")!=null){            ret.setStructural(true);        }        if(props.getProperty("Type")!=null){            try {                ret.setType(Class.forName(props.getProperty("Type")));            } catch (ClassNotFoundException ex) {                System.err.println("DescriptorFactory: Class '"+props.getProperty("Type")+"' is not found in the classpath");                ret.setType(Object.class);            }        }else{            ret.setType(Object.class);        }        return ret;    }        /**     * Creates an input descriptor for the given parameters     *      * Class of the input descriptor is determined by the 'Class' property. Currently     * only the BasicInputDescriptor is created regardless of its value.     *      * Other parameters:     * <ul>     * <li>Type - class of input required (see InputDescriptor for description of the types):     *  <ul><li>Actor     *  <li>ActorProperty     *  <li>Graph     *  <li>GraphProperty     *  <li>Link     *  <li>Path</ul>     * <li>Relation - string describing the name of the relation (type, mode) of the input.     * <li>Property - string describing the name of the input property.     * <li>AlgorithmName - name of the component that is described by this input descriptor.     * </ul>     * @param props map of parameters for creating the input descriptor.     * @return newly created input descriptor     */    public InputDescriptorInternal createInputDescriptor(java.util.Properties props){        if(props == null){            System.err.println("CreateDescriptor.InputDescriptor: WARNING-null value for properties: using defaults");            return new BasicInputDescriptor();        }                InputDescriptorInternal ret = null;                if(props.getProperty("Class")==null){            ret = new BasicInputDescriptor();        }else{            ret = new BasicInputDescriptor();        }                if(props.getProperty("Type")==null){            System.err.println("'Type' Missing - assuming Actor");            ret.setClassType(InputDescriptor.Type.ACTOR);        }else if("Graph".contentEquals(props.getProperty("Type"))){            ret.setClassType(InputDescriptor.Type.GRAPH);        }else if("GraphProperty".contentEquals(props.getProperty("Type"))){            ret.setClassType(InputDescriptor.Type.GRAPH_PROPERTY);        }else if("Path".contentEquals(props.getProperty("Type"))){            ret.setClassType(InputDescriptor.Type.PATHSET);        }else if("Link".contentEquals(props.getProperty("Type"))){            ret.setClassType(InputDescriptor.Type.LINK);        }else if("LinkProperty".contentEquals(props.getProperty("Type"))){            ret.setClassType(InputDescriptor.Type.LINK_PROPERTY);        }else if("Actor".contentEquals(props.getProperty("Type"))){            ret.setClassType(InputDescriptor.Type.ACTOR);        }else if("ActorProperty".contentEquals(props.getProperty("Type"))){            ret.setClassType(InputDescriptor.Type.ACTOR_PROPERTY);        }else{            System.err.println("'Type' '"+props.getProperty("Type")+"' is not a valid type - assuming Actor");            ret.setClassType(InputDescriptor.Type.ACTOR);        }                ret.setRelation(props.getProperty("Relation"));        ret.setProperty(props.getProperty("Property"));        if(props.getProperty("AlgorithmName")==null){            System.err.println("INTERNAL ERROR Mising algorithm name - correct in algorithm init() method");            ret.setAlgorithmName("");        }else{            ret.setAlgorithmName(props.getProperty("AlgorithmName"));        }        return ret;    }        /**     * Creates an output descriptor for the given parameters     *      * Class of the output descriptor is determined by the 'Class' property. Currently     * only the BasicOutputDescriptor is created regardless of its value.     *      * Other parameters:     * <ul>     * <li>Type - class of output produced (see OutputDescriptor for description of the types):     *  <ul><li>Actor     *  <li>ActorProperty     *  <li>Graph     *  <li>GraphProperty     *  <li>Link     *  <li>Path</ul>     * <li>Relation - string describing the name of the relation (type, mode) of the output.     * <li>Property - string describing the name of the output property.     * <li>AlgorithmName - name of the component that is described by this output descriptor.     * </ul>     * @param props map of parameters for creating the output descriptor.     * @return newly created output descriptor     */    public OutputDescriptorInternal createOutputDescriptor(java.util.Properties props){        if(props == null){            System.err.println("CreateDescriptor.InputDescriptor: WARNING-null value for properties: using defaults");            return new BasicOutputDescriptor();        }                OutputDescriptorInternal ret = null;                if(props.getProperty("Class")==null){            ret = new BasicOutputDescriptor();        }else{            ret = new BasicOutputDescriptor();        }                if(props.getProperty("Type")==null){            System.err.println("'Type' Missing - assuming Actor");            ret.setClassType(OutputDescriptor.Type.ACTOR);        }else if("Graph".contentEquals(props.getProperty("Type"))){            ret.setClassType(OutputDescriptor.Type.GRAPH);        }else if("GraphProperty".contentEquals(props.getProperty("Type"))){            ret.setClassType(OutputDescriptor.Type.GRAPH_PROPERTY);        }else if("Path".contentEquals(props.getProperty("Type"))){            ret.setClassType(OutputDescriptor.Type.PATHSET);        }else if("Link".contentEquals(props.getProperty("Type"))){            ret.setClassType(OutputDescriptor.Type.LINK);        }else if("LinkProperty".contentEquals(props.getProperty("Type"))){            ret.setClassType(OutputDescriptor.Type.LINK_PROPERTY);        }else if("Actor".contentEquals(props.getProperty("Type"))){            ret.setClassType(OutputDescriptor.Type.ACTOR);        }else if("ActorProperty".contentEquals(props.getProperty("Type"))){            ret.setClassType(OutputDescriptor.Type.ACTOR_PROPERTY);        }else{            System.err.println("'Type' '"+props.getProperty("Type")+"' is not a valid type - assuming Actor");            ret.setClassType(OutputDescriptor.Type.ACTOR);        }                ret.setRelation(props.getProperty("Relation"));        ret.setProperty(props.getProperty("Property"));        if(props.getProperty("AlgorithmName")==null){            System.err.println("INTERNAL ERROR Mising algorithm name - correct in algorithm init() method");            ret.setAlgorithmName("");        }else{            ret.setAlgorithmName(props.getProperty("AlgorithmName"));        }        return ret;        }    }