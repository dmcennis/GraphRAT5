/* * PostgresqlGraph.java * * Created on 31 July 2007, 11:27 * * Copyright Daniel McEnnis, published under Aferro GPL (see license.txt) */package nz.ac.waikato.mcennis.rat.graph;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;import java.util.logging.Level;import java.util.logging.Logger;import org.dynamicfactory.descriptors.DescriptorFactory;import org.mcennis.graphrat.graph.DerbyGraph;/** * Sub-class of the DerbyGraph Object to work with postgresql databases * * @author Daniel McEnnis *  */public class PostgresqlGraph extends DerbyGraph {    String user = "posgres";    /** Creates a new instance of PostgresqlGraph */    public PostgresqlGraph() {        init(null);    }    /**     * Performs postgresql initialization rather than DerbyGraph     * FIXME: initActor for postgresql is needed     */    public void startup() throws SQLException {        try {            Class.forName("org.postgresql.Driver");            String startup = "jdbc:postgresql:" + database + "?user=" + user;            System.out.println(startup);            connection = java.sql.DriverManager.getConnection(startup);            java.sql.Statement stat = connection.createStatement();            java.sql.ResultSet id = stat.executeQuery("SELECT id FROM Graph");            if (id.next()) {                graphID = id.getInt("id");            }            super.prepareStatement();            connection.setAutoCommit(false);        } catch (ClassNotFoundException ex) {            ex.printStackTrace();        }    }    /**     * Performs Postgresql specific database initialization     */    public void initializeDatabase() throws SQLException {        try {            Class.forName("org.postgresql.Driver");            connection = java.sql.DriverManager.getConnection("jdbc:postgresql:" + database + "?user=" + user);            Statement stat = connection.createStatement();            try {                stat.executeUpdate("CREATE TABLE Graph (" +                        "id SERIAL," +                        "name varchar(256) not null, " +                        "primary key(id))");            } catch (SQLException ex) {                System.err.println("GRAPH: " + ex.getMessage());            }            try {                stat.executeUpdate("CREATE TABLE SubGraph (" +                        "parent integer not null, " +                        "child integer not null, " +                        //                        "FOREIGN KEY (parent) REFERENCES Graph(id)," +                        //                        "FOREIGN KEY (child) REFERENCES Graph(id)," +                        "PRIMARY KEY(parent,child)" +                        ")");            } catch (SQLException ex) {                System.err.println("SUBGRAPH: " + ex.getMessage());            }            try {                stat.executeUpdate("CREATE TABLE Actor (" +                        "id SERIAL," +                        "type VARCHAR(64) not null, " +                        "name VARCHAR(256) not null, " +                        "PRIMARY KEY(id)" +                        ")");                stat.executeUpdate("CREATE INDEX actor_type_index ON Actor(type)");                stat.executeUpdate("CREATE INDEX actor_name_index ON Actor(name)");                stat.executeUpdate("CREATE INDEX actor_index ON Actor(type,name)");            } catch (SQLException ex) {                System.err.println("ACTOR: " + ex.getMessage());            }            try {                stat.executeUpdate("CREATE TABLE ActorGraph (" +                        "graph integer not null," +                        "actor integer not null," +                        //                        "FOREIGN KEY (graph) REFERENCES Graph(id)," +                        //                        "FOREIGN KEY (actor) REFERENCES Actor(id)," +                        "PRIMARY KEY (graph,actor)" +                        ")");            } catch (SQLException ex) {                System.err.println("ACTORGRAPH: " + ex.getMessage());            }            try {                stat.executeUpdate("CREATE TABLE ActorProperties(" +                        "id integer not null, " +                        "type VARCHAR(256) , " +                        "value VARCHAR(256) , " +                        //                        "FOREIGN KEY(id) REFERENCES Actor(id), " +                        "PRIMARY KEY(id,type,value)" +                        ")");                stat.executeUpdate("CREATE INDEX ActorProperty_idtype_index ON ActorProperties(id,type)");            } catch (SQLException ex) {                System.err.println("ACTORPROPERTIES: " + ex.getMessage());            }            try {                stat.executeUpdate("CREATE TABLE GraphProperties (" +                        "id integer not null, " +                        "type VARCHAR(256) , " +                        "value VARCHAR(256) , " +                        //                        "FOREIGN KEY(id) REFERENCES Graph(id), " +                        "PRIMARY KEY(id,type,value)" +                        ")");            } catch (SQLException ex) {                System.err.println("GRAPHPROPERTIES: " + ex.getMessage());            }            try {                stat.executeUpdate("CREATE TABLE Link (" +                        "id SERIAL, " +                        "type VARchar(256)," +                        "start integer, " +                        "finish integer, " +                        "cost double precision, " +                        //                        "FOREIGN KEY (start) REFERENCES Actor(id)," +                        //                        "FOREIGN KEY (finish) REFERENCES Actor(id)," +                        "PRIMARY KEY (id)" +                        ")");                stat.executeUpdate("CREATE INDEX Link_type ON Link(type)");                stat.executeUpdate("CREATE INDEX Link_type_start ON Link(type,start)");                stat.executeUpdate("CREATE INDEX Link_type_finish ON Link(type,finish)");                stat.executeUpdate("CREATE INDEX Link_all ON Link(type,start,finish)");                stat.executeUpdate("CREATE INDEX Link_start_finish ON Link(start,finish)");            } catch (SQLException ex) {                System.err.println("LINK: " + ex.getMessage());            }            try {                stat.executeUpdate("CREATE Table LinkGraph (" +                        "link integer not null, " +                        "graph integer not null, " +                        //                        "FOREIGN KEY (link) REFERENCES Link(id), " +                        //                        "FOREIGN KEY (graph) REFERENCES Graph(id), " +                        "PRIMARY KEY (link,graph)" +                        ")");            } catch (SQLException ex) {                System.err.println("LINKGRAPH: " + ex.getMessage());            }            try {                stat.executeUpdate("CREATE TABLE PathSet (" +                        "id SERIAL, " +                        "name VARchar(256) not null unique, " +                        "PRIMARY KEY (id)" +                        ")");            } catch (SQLException ex) {                System.err.println("PATHSET: " + ex.getMessage());            }            try {                stat.executeUpdate("CREATE TABLE Path (" +                        "id SERIAL, " +                        "name VARchar(256) not null, " +                        "cost double precision, " +                        "PRIMARY KEY (id) " +                        ")");            } catch (SQLException ex) {                System.err.println("PATH: " + ex.getMessage());            }            try {                stat.executeUpdate("CREATE TABLE PathActor (" +                        "path integer not null, " +                        "actor integer not null, " +                        "index integer not null, " +                        //                        "FOREIGN KEY(path) REFERENCES Path(id), " +                        //                        "FOREIGN KEY(actor) REFERENCES Actor(id), " +                        "PRIMARY KEY (path,actor)" +                        ")");            } catch (SQLException ex) {                System.err.println("PATHACTOR: " + ex.getMessage());            }            try {                stat.executeUpdate("CREATE TABLE PathSetPath (" +                        "pathSet integer not null, " +                        "path integer not null, " +                        //                        "FOREIGN KEY (path) REFERENCES Path(id), " +                        //                        "FOREIGN KEY (pathSet) REFERENCES PathSet(id), " +                        "PRIMARY KEY (pathSet,path)" +                        ")");            } catch (SQLException ex) {                System.err.println("PATHSETPATH: " + ex.getMessage());            }            try {                stat.executeUpdate("INSERT INTO Graph (name) VALUES ( '" + database + "' )");            } catch (SQLException ex) {                System.err.println("INSERT: " + ex.getMessage());            }            connection.close();        } catch (ClassNotFoundException ex) {            ex.printStackTrace();        }    }    /**     * Sets the username for the postgresql database     *      * @param u username to be used for the database     */    public void setUser(String u) {        user = u;    }    /**     * Returns the username that is used or will be used by the graph     * @return username     */    public String getUser() {        return user;    }            @Override    public Parameter[] getParameters() {        return parameter;    }        @Override    public void init(Properties map) {        Properties props = new Properties();        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "GraphUser");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[0] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("GraphUser") != null)) {            parameter[0].setValue(map.getProperty("GraphUser"));            user = map.getProperty("GraphUser");        } else {            parameter[0].setValue(user);        }        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "GraphID");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[1] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("GraphID") != null)) {                database = map.getProperty("GraphID");                parameter[1].setValue(database);        } else {            parameter[1].setValue("Root");        }                props.setProperty("Type", "java.lang.Boolean");        props.setProperty("Name", "GraphInitialize");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[2] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("GraphInitialize")!=null) &&(Boolean.parseBoolean(map.getProperty("GraphInitialize")))) {            try {                initializeDatabase();            } catch (SQLException ex) {                Logger.getLogger(PostgresqlGraph.class.getName()).log(Level.SEVERE, null, ex);            }        }                props.setProperty("Type", "java.lang.Boolean");        props.setProperty("Name", "GraphStartup");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[3] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("GraphStartup")!=null) &&(Boolean.parseBoolean(map.getProperty("GraphStartup")))) {            try {                startup();            } catch (SQLException ex) {                Logger.getLogger(PostgresqlGraph.class.getName()).log(Level.SEVERE, null, ex);            }        }                        props.setProperty("Type", "java.lang.Boolean");        props.setProperty("Name", "GraphClear");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[4] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("GraphClear") != null)&&(Boolean.parseBoolean(map.getProperty("GraphClear")))&&(map.getProperty("GraphStartup")!=null) &&(Boolean.parseBoolean(map.getProperty("GraphStartup")))) {            clear();        }                props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "actorClass");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[5] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("actorClass") != null)) {                parameter[5].setValue(map.getProperty("actorClass"));        } else {            parameter[5].setValue("DBActor");        }                props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "linkClass");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[6] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("linkClass") != null)) {                parameter[6].setValue(map.getProperty("linkClass"));        } else {            parameter[6].setValue("DBLink");        }            }}