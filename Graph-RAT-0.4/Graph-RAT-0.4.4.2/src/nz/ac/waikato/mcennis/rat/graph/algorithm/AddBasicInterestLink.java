/* * BasicInterestLink.java * * Created on 12 June 2007, 20:21 * * Copyright Daniel McEnnis, published under Aferro GPL (see license.txt) */package nz.ac.waikato.mcennis.rat.graph.algorithm;import java.util.HashMap;import java.util.Properties;import nz.ac.waikato.mcennis.rat.graph.Graph;import nz.ac.waikato.mcennis.rat.graph.actor.Actor;import nz.ac.waikato.mcennis.rat.graph.descriptors.DescriptorFactory;import nz.ac.waikato.mcennis.rat.graph.descriptors.InputDescriptor;import nz.ac.waikato.mcennis.rat.graph.descriptors.InputDescriptorInternal;import nz.ac.waikato.mcennis.rat.graph.descriptors.OutputDescriptor;import nz.ac.waikato.mcennis.rat.graph.descriptors.OutputDescriptorInternal;import nz.ac.waikato.mcennis.rat.graph.descriptors.Parameter;import nz.ac.waikato.mcennis.rat.graph.descriptors.ParameterInternal;import nz.ac.waikato.mcennis.rat.graph.descriptors.SettableParameter;import nz.ac.waikato.mcennis.rat.graph.property.Property;import nz.ac.waikato.mcennis.rat.graph.link.Link;import nz.ac.waikato.mcennis.rat.graph.link.LinkFactory;import java.util.Iterator;import nz.ac.waikato.mcennis.rat.graph.model.ModelShell;/** * Creates an interest link using exponential similarity to take bag-of-words  * from a property list to create a link between actors represetning the degree * of which their interest overlaps. *  * * @author Daniel McEnnis *  */public class AddBasicInterestLink extends ModelShell implements Algorithm {    public static final long serialVersionUID = 2;    private ParameterInternal[] parameter = new ParameterInternal[10];    private InputDescriptorInternal[] input = new InputDescriptorInternal[3];    private OutputDescriptorInternal[] output = new OutputDescriptorInternal[1];//    private double positiveBase=1.0;//    private double positiveRate=1.5;//    private double negativeBase=0.5;//    private double negativeRate=1.3;    private double leftCount = 0.0;    private double rightCount = 0.0;    /** Creates a new instance of BasicInterestLink */    public AddBasicInterestLink() {        init(null);    }    /**     * Reads a property list on each actors and calculate all similar actors      * connected with a given link set.     *      * @param g graph to be modified     */    public void execute(Graph g) {//        Actor[] userList = g.getActor("User");        Iterator<Actor> userIterator = g.getActorIterator((String) parameter[2].getValue());        while (userIterator.hasNext()) {            Actor user = userIterator.next();            Property leftProps = user.getProperty((String) parameter[3].getValue());            if ((leftProps != null) && (leftProps.getPropertyClass().getName().contentEquals("java.lang.String"))) {                Object[] leftInterest = leftProps.getValue();                Link[] links = g.getLinkBySource((String) parameter[1].getValue(), user);                if (links != null) {                    for (int j = 0; j < links.length; ++j) {                        Actor dest = links[j].getDestination();                        Property rightProps = dest.getProperty((String) parameter[3].getValue());                        if ((rightProps != null) && (rightProps.getPropertyClass().getName().contentEquals("java.lang.String"))) {                            Object[] rightInterest = rightProps.getValue();                            double between = getBetweeness(dest);                            compareInterests(leftInterest, rightInterest, between);//                        if(leftCount>2.0){                            java.util.Properties props = new java.util.Properties();                            props.setProperty("LinkType", (String) parameter[4].getValue());                            Link ul = LinkFactory.newInstance().create(props);                            ul.set(user, leftCount, dest);                            g.add(ul);//                        }if(rightCount>2.0){//                            ul = LinkFactory.newInstance().create("Interest",null);//                            ul.set(dest,rightCount,userList[i]);//                            g.add(ul);//                        }                        }                    }                }            }        }    }//    public void setPositiveRate(double rate){//        positiveRate = rate;//    }////    public double getPositiveRate(){//        return positiveRate;//    }////    public void setNegativeRate(double rate){//        negativeRate = rate;//    }////    public double getNegativeRate(){//        return negativeRate;//    }////    public void setPositiveBase(double rate){//        positiveBase = rate;//    }////    public double getPositiveBase(){//        return positiveBase;//    }////    public void setNegativeBase(double rate){//        negativeBase = rate;//    }////    public double getNegativeBase(){//        return negativeBase;//    }    /**     * Exponential similarity measure between two users.  All words are binary on-off     *      * Algorithm:     *      * positiveBase*(1+positiveExponent*actorBetweeness)^(#shared Interest)     * - negativeBase*(1+negativeExponent*actorBetweeness)^(left actor # interest - #shared Interest)     *      *     * @param left source of link     * @param right destination of link     * @param betweeness betweeness value of destination     */    public void compareInterests(Object[] left, Object[] right, double betweeness) {        int positiveCount = 0;        int negativeCount = 0;        if (left == null) {            leftCount = 0.0;        } else if (right == null) {            leftCount = 0.0;            for (int i = 0; i < left.length - positiveCount; ++i) {                leftCount += ((Double) parameter[8].getValue()) * Math.pow(1 + ((Double) parameter[9].getValue()) * betweeness, (double) i);//            ret -= negativeBase*Math.pow(negativeRate,(double)i);            }        } else {            java.util.Arrays.sort(left);            java.util.Arrays.sort(right);            int i = 0;            int j = 0;            double ret;            while ((i < left.length) && (j < right.length)) {                if (((String) left[i]).compareTo((String) right[j]) > 0) {                    ++j;                } else if (((String) left[i]).compareTo((String) right[j]) < 0) {                    ++i;                } else {                    positiveCount++;                    ++i;                    ++j;                }            }            ret = 0.0;            rightCount = 0.0;            for (i = 0; i < positiveCount; ++i) {                ret += ((Double) parameter[6].getValue()) * Math.pow(1 + ((Double) parameter[7].getValue()) * betweeness, (double) i);//            ret += positiveBase*Math.pow(positiveRate,(double)i);            }            rightCount = leftCount;            for (i = 0; i < left.length - positiveCount; ++i) {                ret += ((Double) parameter[8].getValue()) * Math.pow(1 + ((Double) parameter[9].getValue()) * betweeness, (double) i);//            ret -= negativeBase*Math.pow(negativeRate,(double)i);            }            leftCount = ret;//        for(i=0;i<right.length-positiveCount;++i){//            rightCount -= negativeBase*Math.pow(negativeRate,(double)i);//        }        }    }    /**     * get betweeness value for a given actor     *      * @param dest destination actor     */    double getBetweeness(Actor dest) {        Property props = dest.getProperty((String) parameter[5].getValue());        if ((props != null) && (props.getPropertyClass().getName().contentEquals("Double"))) {            Object[] value = dest.getProperty((String) parameter[5].getValue()).getValue();            if (value != null) {                return ((Double) props.getValue()[0]).doubleValue();            }        }        return 1.0;    }    @Override    public InputDescriptor[] getInputType() {        return input;    }    @Override    public OutputDescriptor[] getOutputType() {        return output;    }    @Override    public Parameter[] getParameter() {        return parameter;    }    @Override    public Parameter getParameter(String param) {        for (int i = 0; i < parameter.length; ++i) {            if (parameter[i].getName().contentEquals(param)) {                return parameter[i];            }        }        return null;    }    @Override    public SettableParameter[] getSettableParameter() {        return new SettableParameter[]{parameter[6], parameter[7], parameter[8], parameter[9]};    }    @Override    public SettableParameter getSettableParameter(String param) {        for (int i = 6; i < 10; ++i) {            if (parameter[i].getName().contentEquals(param)) {                return parameter[i];            }        }        return null;    }    /**     * Parameters for intializing this object     *      * <ol>     * <li>'name' - Name of this isntance of the algorithm. Default is 'Basic Interest Link'     * <li>'relation' - Name of the link type (relation) to be used. Default is 'Knows'     * <li>'actorType' - name of the actor type (mode) to be used. Default is 'User'     * <li>'dataPropertyType' - name of the property where interests are stored. Default is 'interest'.     * <li>'outputLinkType' - name of the type (relation) of link to be created. Default is 'Interest'.     * <li>'adjustorPropertyType' - name of the property type where prestige is stored. Default is 'Knows Betweeness'.     * <li>'positiveBase' - see compareInterests. Default is '2.0'.     * <li>'positiveExponent' - see compareInterests. Default is '0.5'.     * <li>'negativeBase' - see compareInterests. Default is '0.5'.     * <li>'negativeExponent' - see compareInterests Default is '0.3'.     * </ol>     *      * inputs     * <ol>     * <li>Link     * <li>Property - list of interests     * <li>Property - prestige scores of actors     * </ol>     *      * outputs     * <ol><li>Link - Interest links between actors     * </ol>     *      * @param map set of parameters for this object     */    public void init(Properties map) {        // init paramters        Properties props = new Properties();        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "name");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[0] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("name") != null)) {            parameter[0].setValue(map.getProperty("name"));        } else {            parameter[0].setValue("Basic Interest Link");        }        // Parameter 1 - relation        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "relation");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[1] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("relation") != null)) {            parameter[1].setValue(map.getProperty("relation"));        } else {            parameter[1].setValue("Knows");        }        // Parameter 2 - actor type        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "actorType");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[2] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("actorType") != null)) {            parameter[2].setValue(map.getProperty("actorType"));        } else {            parameter[2].setValue("User");        }        // Parameter 3 - property type        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "dataPropertyType");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[3] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("dataPropertyType") != null)) {            parameter[3].setValue(map.getProperty("dataPropertyType"));        } else {            parameter[3].setValue("interest");        }        // Parameter 4 - output link type        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "outputLinkType");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[4] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("outputLinkType") != null)) {            parameter[4].setValue(map.getProperty("outputLinkType"));        } else {            parameter[4].setValue("Interest");        }        // Parameter 5 - adjustor property type        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "adjustorPropertyType");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[5] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("adjustorPropertyType") != null)) {            parameter[5].setValue(map.getProperty("adjustorPropertyType"));        } else {            parameter[5].setValue("Knows Betweeness");        }        // Parameter 6 - positive base        props.setProperty("Type", "java.lang.Double");        props.setProperty("Name", "positiveBase");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "false");        parameter[6] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("positiveBase") != null)) {            parameter[6].setValue(Double.parseDouble(map.getProperty("positiveBase")));        } else {            parameter[6].setValue(new Double(1.0));        }        // Parameter 7 - positive exponent        props.setProperty("Type", "java.lang.Double");        props.setProperty("Name", "positiveExponent");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "false");        parameter[7] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("positiveExponent") != null)) {            parameter[7].setValue(Double.parseDouble(map.getProperty("positiveExponent")));        } else {            parameter[7].setValue(new Double(0.5));        }        // Parameter 8 - negative base        props.setProperty("Type", "java.lang.Double");        props.setProperty("Name", "negativeBase");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "false");        parameter[8] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("negativeBase") != null)) {            parameter[8].setValue(Double.parseDouble(map.getProperty("negativeBase")));        } else {            parameter[8].setValue(new Double(0.5));        }        // Parameter 9 - negative exponent        props.setProperty("Type", "java.lang.Double");        props.setProperty("Name", "negativeExponent");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "false");        parameter[9] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("negativeExponent") != null)) {            parameter[9].setValue(Double.parseDouble(map.getProperty("negativeExponent")));        } else {            parameter[9].setValue(new Double(0.3));        }        // init input 0        props.setProperty("Type", "Link");        props.setProperty("Relation", (String) parameter[1].getValue());        props.setProperty("AlgorithmName", (String) parameter[0].getValue());        props.remove("Property");        input[0] = DescriptorFactory.newInstance().createInputDescriptor(props);        // init input 1        props.setProperty("Type", "ActorProperty");        props.setProperty("Relation", (String) parameter[2].getValue());        props.setProperty("AlgorithmName", (String) parameter[0].getValue());        props.setProperty("Property", (String) parameter[3].getValue());        input[0] = DescriptorFactory.newInstance().createInputDescriptor(props);        // init input 2        props.setProperty("Type", "ActorProperty");        props.setProperty("Relation", (String) parameter[2].getValue());        props.setProperty("AlgorithmName", (String) parameter[0].getValue());        props.setProperty("Property", (String) parameter[5].getValue());        input[0] = DescriptorFactory.newInstance().createInputDescriptor(props);        // init output 0        // Construct Output Descriptors        props.setProperty("Type", "Link");        props.setProperty("Relation", (String) parameter[4].getValue());        props.setProperty("AlgorithmName", (String) parameter[0].getValue());        props.remove("Property");        output[0] = DescriptorFactory.newInstance().createOutputDescriptor(props);    }}