/* * OptimizedCloseness.java * * Created on 22 October 2007, 14:36 * * Copyright Daniel McEnnis, published under Aferro GPL (see license.txt) */package nz.ac.waikato.mcennis.rat.graph.algorithm;import java.util.Arrays;import java.util.HashSet;import java.util.Hashtable;import java.util.Iterator;import java.util.Properties;import java.util.logging.Level;import java.util.logging.Logger;import nz.ac.waikato.mcennis.rat.graph.Graph;import nz.ac.waikato.mcennis.rat.graph.actor.Actor;import org.dynamicfactory.descriptors.DescriptorFactory;import org.dynamicfactory.descriptors.InputDescriptor;import org.dynamicfactory.descriptors.OutputDescriptor;import org.dynamicfactory.descriptors.SettableParameter;import nz.ac.waikato.mcennis.rat.graph.link.Link;import org.dynamicfactory.model.ModelShell;import nz.ac.waikato.mcennis.rat.graph.path.PathNode;import nz.ac.waikato.mcennis.rat.scheduler.Scheduler;/** * Class that calculates geodesic paths using Djikstra's spanning tree algorithm * Hooks are provided for subclasses to use each spanning tree for one actor so * that the algorithms can become linear in space rather than O(n2). * * @author Daniel McEnnis *  */public abstract class OptimizedPathBase extends ModelShell implements Algorithm {    ParameterInternal[] parameter = new ParameterInternal[4];    InputDescriptor[] input = new InputDescriptor[1];    OutputDescriptor[] output = null;    Hashtable<Actor, Integer> actorToID = new Hashtable<Actor, Integer>();    protected PathNode[] path = null;    /** Creates a new instance of OptimizedCloseness */    public OptimizedPathBase() {        init(null);    }    /**     * Generates a spanning tree for a given actor.  Calls the abstract methods:     * <br>setSize - gives the derived class the size of the user list.     * <br>doAnalysis - gives a set of PathNodes and the root of the tree.     * <br>doCleanup - allows any extra calculations to be made before the algorithm     * returns control to the scheduler.     *     */    public void execute(Graph g) {        HashSet<PathNode> lastSet = new HashSet<PathNode>();        HashSet<PathNode> nextSet = new HashSet<PathNode>();        HashSet<PathNode> seen = new HashSet<PathNode>();        Actor[] a = g.getActor((String) parameter[2].getValue());        if (a != null) {            Arrays.sort(a);            for (int i = 0; i < a.length; ++i) {                actorToID.put(a[i], i);            }            path = new PathNode[a.length];            fireChange(Scheduler.SET_ALGORITHM_COUNT, a.length);            for (int i = 0; i < path.length; ++i) {                path[i] = new PathNode();                path[i].setId(i);                path[i].setActor(a[i]);            }            setSize(path.length);            // determine max length of each element sequentially            for (int i = 0; i < path.length; ++i) {                Logger.getLogger(OptimizedPathBase.class.getName()).log(Level.FINE,"Creating paths from source " + i);                lastSet.clear();                nextSet.clear();                seen.clear();                lastSet.add(path[i]);                seen.add(path[i]);                for (int j = 0; j < path.length; ++j) {                    path[j].setCost(Double.POSITIVE_INFINITY);                    path[j].setPrevious(null);                }                path[i].setCost(0.0);                while (lastSet.size() > 0) {                    Iterator<PathNode> last_it = lastSet.iterator();                    while (last_it.hasNext()) {                        PathNode currentSource = last_it.next();                        Link[] linkSet = g.getLinkBySource((String) parameter[1].getValue(), currentSource.getActor());                        if (linkSet != null) {                            for (int j = 0; j < linkSet.length; ++j) {                                PathNode dest = path[actorToID.get(linkSet[j].getDestination())];                                compare(currentSource, dest, linkSet[j]);                                if (!seen.contains(dest)) {                                    nextSet.add(dest);                                }                                seen.add(dest);                            }                        }                    }                    lastSet = nextSet;                    nextSet = new HashSet<PathNode>();                }                doAnalysis(path, path[i]);                fireChange(Scheduler.SET_ALGORITHM_PROGRESS, i);            }            doCleanup(path, g);        } else {            Logger.getLogger(OptimizedPathBase.class.getName()).log(Level.WARNING,"No Actors of type '" + (String) parameter[2].getValue() + "' were found");        }    }    /**     * Any additional calculations to be performed before control returns to the     * scheduler     * @param path      * @param g      */    protected abstract void doCleanup(PathNode[] path, Graph g);    /**     *      * @param path      * @param source      */    protected abstract void doAnalysis(PathNode[] path, PathNode source);    /**     *      * @param size      */    protected abstract void setSize(int size);    protected void compare(PathNode current, PathNode next, Link link) {        double totalCost = current.getCost() + link.getStrength();        if (next.getCost() > totalCost) {            next.setPrevious(current);            next.setPreviousLink(link);            next.setCost(totalCost);        }    }    @Override    public InputDescriptor[] getInputType() {        return input;    }    @Override    public OutputDescriptor[] getOutputType() {        return output;    }    @Override    public Parameter[] getParameter() {        return parameter;    }    @Override    public Parameter getParameter(String param) {        for (int i = 0; i < parameter.length; ++i) {            if (parameter[i].getName().contentEquals(param)) {                return parameter[i];            }        }        return null;    }    @Override    public SettableParameter[] getSettableParameter() {        return null;    }    @Override    public SettableParameter getSettableParameter(String param) {        return null;    }    /**     * Parameters to be initialized.  Subclasses should override if they provide     * any additional parameters or require additional inputs.     *      * <ol>     * <li>'name' - Name of this instance of the algorithm.  Default is ''.     * <li>'relation' - type (relation) of link to calculate over. Default 'Knows'.     * <li>'actorType' - type (mode) of actor to calculate over. Deafult 'User'.     * <li>'normalize' - boolean for whether or not to normalize prestige vectors.      * Default 'false'.     * </ol>     * <br>     * <br>Input 0 - Link     * <br>NOTE - subclasses define the ouput - see subclasses for output information     */    public void init(Properties map) {        Properties props = new Properties();        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "name");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[0] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("name") != null)) {            parameter[0].setValue(map.getProperty("name"));        } else {            parameter[0].setValue("");        }        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "relation");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[1] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("relation") != null)) {            parameter[1].setValue(map.getProperty("relation"));        } else {            parameter[1].setValue("Knows");        }        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "actorType");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[2] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("actorType") != null)) {            parameter[2].setValue(map.getProperty("actorType"));        } else {            parameter[2].setValue("User");        }        // Parameter 3 - normalize        props.setProperty("Type", "java.lang.Boolean");        props.setProperty("Name", "normalize");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[3] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("normalize") != null)) {            parameter[3].setValue(new Boolean(Boolean.parseBoolean(map.getProperty("normalize"))));        } else {            parameter[3].setValue(new Boolean(false));        }        // Create Input Descriptors        // Construct input descriptors        props.setProperty("Type", "Link");        props.setProperty("Relation", (String) parameter[1].getValue());        props.setProperty("AlgorithmName", (String) parameter[0].getValue());        props.remove("Property");        input[0] = DescriptorFactory.newInstance().createInputDescriptor(props);        // Construct Output Descriptors        constructOutput(output, parameter);    }    /**     * Defines the contents of the output class variable.     * @param output output descriptor.     * @param parameter list of parameters     */    protected abstract void constructOutput(OutputDescriptor[] output, ParameterInternal[] parameter);}