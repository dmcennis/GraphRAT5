/* * AddGeodesicPaths.java * * Created on 5 July 2007, 19:25 * * Copyright Daniel McEnnis, published under Aferro GPL (see license.txt) */package nz.ac.waikato.mcennis.rat.graph.algorithm;import java.util.Properties;import nz.ac.waikato.mcennis.rat.graph.Graph;import nz.ac.waikato.mcennis.rat.graph.descriptors.DescriptorFactory;import nz.ac.waikato.mcennis.rat.graph.descriptors.InputDescriptor;import nz.ac.waikato.mcennis.rat.graph.descriptors.OutputDescriptor;import nz.ac.waikato.mcennis.rat.graph.descriptors.Parameter;import nz.ac.waikato.mcennis.rat.graph.descriptors.ParameterInternal;import nz.ac.waikato.mcennis.rat.graph.descriptors.SettableParameter;import nz.ac.waikato.mcennis.rat.graph.path.Path;import nz.ac.waikato.mcennis.rat.graph.path.PathFactory;import nz.ac.waikato.mcennis.rat.graph.path.PathSet;import nz.ac.waikato.mcennis.rat.graph.path.PathSetFactory;import nz.ac.waikato.mcennis.rat.graph.actor.Actor;import nz.ac.waikato.mcennis.rat.graph.link.Link;import java.util.HashSet;import java.util.HashMap;import java.util.Vector;import java.util.Iterator;import java.util.logging.Level;import java.util.logging.Logger;import nz.ac.waikato.mcennis.rat.graph.model.ModelShell;import nz.ac.waikato.mcennis.rat.scheduler.Scheduler;/** * Class for calculating all geodesic paths over a set of links and set of actors * using a variation of Djikstra's algorithm. * * @author Daniel McEnnis *  */public class AddBasicGeodesicPaths extends ModelShell implements Algorithm {    public static final long serialVersionUID = 2;    HashSet<String> usedCount;    HashMap<String, Integer> map;    HashMap<String, Vector<String>> nodeExpansion;    Actor[] userList;    PathSet pathSet;    PathSet lastPath;    PathSet nextPath;    HashSet<String> seedNodes;    ParameterInternal[] parameter = new ParameterInternal[3];    InputDescriptor[] input = new InputDescriptor[1];    OutputDescriptor[] output = new OutputDescriptor[1];    /** Creates a new instance of AddGeodesicPaths */    public AddBasicGeodesicPaths() {        init(null);    }    /**     * Calculate each path using a variation of Djikstra's algorithm for spanning     * trees with modification for recording multiple same-cost minimum paths.     *      */    public void execute(Graph g) {        java.util.Properties props = new java.util.Properties();        props.setProperty("PathSetType", "Basic");        pathSet = PathSetFactory.newInstance().create(props);        pathSet.setType("Directional Geodesic by " + (String) parameter[1].getValue());        seedNodes = new HashSet<String>();        usedCount = new HashSet<String>();        nodeExpansion = new HashMap<String, Vector<String>>();        userList = g.getActor((String) parameter[2].getValue());        int count = 0;        fireChange(Scheduler.SET_ALGORITHM_COUNT,userList.length);        //        // For every user, calculate all geodesics.        //        // NOTE: iff path p is a geodesic of length n+1 iff the first n nodes        // form a geodesic and node n+1 does not occur in any shorter path.        //        // NOTE: this method enumerates all geodesics in order of length.  It        // ceases searching after consecutive expansions with no new nodes -        // sign of a disconnected graph.        //        // For every user        //    For each length geodesics        //        for (int i = 0; i < userList.length; ++i) {                        if (i % 100 == 0) {                Logger.getLogger(AddBasicGeodesicPaths.class.getName()).log(Level.FINE,"Geodesic set " + i + " of " + userList.length);                fireChange(Scheduler.SET_ALGORITHM_PROGRESS,i);            }            seedNodes.clear();            seedNodes.add(userList[i].getID());            usedCount.clear();            usedCount.add(userList[i].getID());            nodeExpansion.clear();            java.util.Properties properties = new java.util.Properties();            properties.setProperty("PathType", "Basic");            properties.setProperty("PathID", "Base");            properties.setProperty("PathSetType", "Basic");            properties.setProperty("PathSetID", "Base");            Path base = PathFactory.newInstance().create(properties);            lastPath = PathSetFactory.newInstance().create(properties);            base.setPath(new Actor[]{userList[i]}, 0.0, "Base");            lastPath.addPath(base);            // While there exists nodes to be found or new nodes are added            while ((usedCount.size() < userList.length) && (lastPath.size() > 0)) {                // For every last node in list                props.setProperty("PathSetID", "Directional Geodesic by " + parameter[1].getValue());                nextPath = PathSetFactory.newInstance().create(properties);                nextStepNodes(g);                processVectors(g);                lastPath = nextPath;                count++;            }        }// for every user        g.add(pathSet);    }    /**     * Place node expansion into node expansion map.  This must be done every     * user becuase this filters out all nodes that would not create a new     * geodesic.     *     * @param g graph containing the nodes to be parsed.     */    protected void nextStepNodes(Graph g) {        nodeExpansion.clear();        Iterator<String> seed = seedNodes.iterator();        HashSet<String> nextSeed = new HashSet<String>();        while (seed.hasNext()) {            String key = seed.next();            Link[] linkedNodes = g.getLinkBySource((String) parameter[1].getValue(), g.getActor((String) parameter[2].getValue(), key));            if (linkedNodes != null) {                nodeExpansion.put(key, new Vector<String>());                for (int i = 0; i < linkedNodes.length; ++i) {                    String dest = linkedNodes[i].getDestination().getID();                    if (!usedCount.contains(dest)) {                        nodeExpansion.get(key).add(dest);                        nextSeed.add(dest);                    }                }            }        }        usedCount.addAll(nextSeed);        seedNodes = nextSeed;    }    /**     * for each vector in the list     *   process end node for each geodesic     *     * @param g graph for betweeness calculations     */    protected void processVectors(Graph g) {        Iterator<String> seed = nodeExpansion.keySet().iterator();        while (seed.hasNext()) {            String seedString = seed.next();            Path[] base = lastPath.getPathByDestination(seedString);            Vector<String> mapping = nodeExpansion.get(seedString);            if ((base != null) && (mapping != null) && (mapping.size() > 0)) {                for (int i = 0; i < base.length; ++i) {                    for (int j = 0; j < mapping.size(); ++j) {                        Path item = base[i].addActor(g.getActor((String) parameter[2].getValue(), mapping.get(j)), 1.0);                        nextPath.addPath(item);                        pathSet.addPath(item);                    }                }            }            usedCount.add(seedString);        }        lastPath = nextPath;    }    @Override    public InputDescriptor[] getInputType() {        return input;    }    @Override    public OutputDescriptor[] getOutputType() {        return output;    }    @Override    public Parameter[] getParameter() {        return parameter;    }    @Override    public Parameter getParameter(String param) {        for (int i = 0; i < parameter.length; ++i) {            if (parameter[i].getName().contentEquals(param)) {                return parameter[i];            }        }        return null;    }    @Override    public SettableParameter[] getSettableParameter() {        return null;    }    @Override    public SettableParameter getSettableParameter(String param) {        return null;    }    /**     * Initialize a geodesic path object     *      * Parameters:     * <br><ol>     * <li>'name' - the name for this algorithm component. Default is 'Basic Geodesic Paths'.     * <li>'relation' - what type (relation) of link (arc, edge) to calcualte paths over. Default is 'Knows'     * <li>'actorType' - what type (mode) of actor to calculate paths over. Default is 'User'.     * </ol>     * <br>     * <br><b>input 1</b> Link     * <br><b>output 1</b> Path     */    public void init(Properties map) {        Properties props = new Properties();        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "name");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[0] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("name") != null)) {            parameter[0].setValue(map.getProperty("name"));        } else {            parameter[0].setValue("Basic Geodesic Paths");        }        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "relation");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[1] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("relation") != null)) {            parameter[1].setValue(map.getProperty("relation"));        } else {            parameter[1].setValue("Knows");        }        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "actorType");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[2] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("actorType") != null)) {            parameter[2].setValue(map.getProperty("actorType"));        } else {            parameter[2].setValue("User");        }        // Create Input Descriptors        // Construct input descriptors        props.setProperty("Type", "Link");        props.setProperty("Relation", (String) parameter[1].getValue());        props.setProperty("AlgorithmName", (String) parameter[0].getValue());        props.remove("Property");        input[0] = DescriptorFactory.newInstance().createInputDescriptor(props);        // Construct Output Descriptors        props.setProperty("Type", "Path");        props.setProperty("Relation", "Directional Geodesic By " + (String) parameter[1].getValue());        props.setProperty("AlgorithmName", (String) parameter[0].getValue());        props.remove("Property");        output[0] = DescriptorFactory.newInstance().createOutputDescriptor(props);    }}