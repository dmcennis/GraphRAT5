/* * MemGraph.java * * Created on 1 May 2007, 15:01 * * copyright Daniel McEnnis - published under Aferro GPL (see license.txt) */package nz.ac.waikato.mcennis.rat.graph;import java.io.FileWriter;import java.io.IOException;import java.util.HashMap;import java.util.Vector;import java.util.Iterator;import java.util.LinkedList;import java.util.Properties;import java.util.Set;import java.util.logging.Level;import java.util.logging.Logger;import java.util.regex.Pattern;import nz.ac.waikato.mcennis.rat.graph.link.Link;import org.dynamicfactory.model.ModelShell;import nz.ac.waikato.mcennis.rat.graph.page.Page;import nz.ac.waikato.mcennis.rat.graph.actor.Actor;import org.dynamicfactory.descriptors.DescriptorFactory;org.dynamicfactory.propertyQuery.Query;import nz.ac.waikato.mcennis.rat.graph.path.PathSet;import nz.ac.waikato.mcennis.rat.graph.path.Path;import org.dynamicfactory.property.PropertyTypeRegister;/** * A graph object that is held entirely in memory * * @see nz.ac.waikato.mcennis.arm.graph.Graph * * @author Daniel McEnnis * */public class MemGraph extends ModelShell implements Graph, java.io.Serializable {    static final long serialVersionUID = 3;    /**     * Map of actor ids to user objects by type of actor     */    HashMap<String, HashMap<String, Actor>> actor;    /**     * three level object.  First level is a hashmap of userlinks based on type.     * Second level hashmap is of source user ids.  The third level is a vector     * of all userlinks that map to the same type and source user.     *     * It is assumed that types will enforce their own restrictions on the type     * of each actor in the link.     */    HashMap<String, HashMap<String, HashMap<String, Vector<Link>>>> links;    HashMap<String, HashMap<String, HashMap<String, Vector<Link>>>> invertedLinks;//    GraphIndex index = new GraphIndex();    HashMap<String, Property> properties;    HashMap<String, PathSet> pathSets;    Graph parent = null;    java.util.LinkedList<Graph> children = new java.util.LinkedList<Graph>();    String name;    UserIDList mapped = null;    java.io.Writer outs = null;    boolean gzip = true;    ParameterInternal[] parameter = new ParameterInternal[3];    /** Creates a new instance of MemGraph */    public MemGraph() {        actor = new HashMap<String, HashMap<String, Actor>>();        links = new HashMap<String, HashMap<String, HashMap<String, Vector<Link>>>>();        invertedLinks = new HashMap<String, HashMap<String, HashMap<String, Vector<Link>>>>();        properties = new HashMap<String, Property>();        pathSets = new HashMap<String, PathSet>();        init(null);    }    @Override    public void add(Link link) {        if ((mapped == null) || (mapped.getActor(link.getDestination().getType(), link.getDestination().getID()) != null)) {            String type = link.getType();            Actor source = link.getSource();            Actor dest = link.getDestination();            //            if((source != null)&&(dest != null)){            if (!links.containsKey(type)) {                links.put(type, new HashMap<String, HashMap<String, Vector<Link>>>());            }            if (!invertedLinks.containsKey(type)) {                invertedLinks.put(type, new HashMap<String, HashMap<String, Vector<Link>>>());            }            HashMap<String, HashMap<String, Vector<Link>>> typeLink = links.get(type);            HashMap<String, HashMap<String, Vector<Link>>> typeInvertedLink = invertedLinks.get(type);            if (!typeLink.containsKey(source.getType())) {                typeLink.put(source.getType(), new HashMap<String, Vector<Link>>());            }            if (!typeInvertedLink.containsKey(dest.getType())) {                typeInvertedLink.put(dest.getType(), new HashMap<String, Vector<Link>>());            }            HashMap<String, Vector<Link>> idLink = typeLink.get(source.getType());            HashMap<String, Vector<Link>> idInvertedLink = typeInvertedLink.get(dest.getType());            if (!idLink.containsKey(source.getID())) {                idLink.put(source.getID(), new Vector<Link>());            }            if (!idInvertedLink.containsKey(dest.getID())) {                idInvertedLink.put(dest.getID(), new Vector<Link>());            }            idLink.get(source.getID()).add(link);            idInvertedLink.get(dest.getID()).add(link);            if (parent != null) {                parent.add(link);            }        }    }    @Override    public void add(Actor u) {        if ((mapped == null) || (mapped.getActor(u.getType(), u.getID()) != null)) {            if (!actor.containsKey(u.getType())) {                actor.put(u.getType(), new HashMap<String, Actor>());            }            HashMap<String, Actor> entry = actor.get(u.getType());            entry.put(u.getID(), u);            if (parent != null) {                parent.add(u);            }        }//        index.addActor(u, this);    }    @Override    public Actor getActor(String type, String ID) {        if (actor.get(type) != null) {            return actor.get(type).get(ID);        } else {            return null;        }    }    @Override    public Actor[] getActor(String type) {        HashMap<String, Actor> actorClass = actor.get(type);        if (actorClass != null) {            return actorClass.values().toArray(new Actor[]{});        } else {            return null;        }    }    /**     * Serializes MemGraphs to an XML file     * @param output output stream to serialize into     * @param isInnerGraph is this the root graph (requiring headers) or an inner     * graph.     * @throws java.io.IOException     */    public void outputXML(java.io.Writer output, boolean isInnerGraph) throws java.io.IOException {        if (!isInnerGraph) {            output.append("<?xml version=\"1.0\"?>\n");            output.append("<!DOCTYPE dataObject [\n");            output.append("  <!ELEMENT dataObject (graph)>\n");            output.append("  <!ELEMENT graph (graphClass,graphName,graphProperties*,pathSet*,user*,userLink*,graph*)>\n");            output.append("  <!ELEMENT graphClass (#PCDATA)>\n");            output.append("  <!ELEMENT graphName (#PCDATA)>\n");            output.append("  <!ELEMENT graphProperties (gClass,gValueClass,gType,gValue+)>\n");            output.append("  <!ELEMENT gClass (#PCDATA)>\n");            output.append("  <!ELEMENT gValueClass (#PCDATA)>\n");            output.append("  <!ELEMENT gType (#PCDATA)>\n");            output.append("  <!ELEMENT gValue (#PCDATA)>\n");            output.append("  <!ELEMENT pathSet (path+)>\n");            output.append("  <!ELEMENT path (actor+)>\n");            output.append("  <!ELEMENT actor (actorType,actorID)>\n");            output.append("  <!ELEMENT actorType (#PCDATA)>\n");            output.append("  <!ELEMENT actorID (#PCDATA)>\n");            output.append("  <!ELEMENT user (userClass,ID,properties*,page*)>\n");            output.append("  <!ELEMENT ID (#PCDATA)>\n");            output.append("  <!ELEMENT properties (propertiesClass,valueClass,type,value*)>\n");            output.append("  <!ELEMENT type (#PCDATA)>\n");            output.append("  <!ELEMENT value (#PCDATA)>\n");            output.append("  <!ELEMENT valueClass (#PCDATA)>\n");            output.append("  <!ELEMENT userLink (uClass,uStrength,uSourceType,uSourceID,uDestinationType,uDestinationID,uProperties)>\n");            output.append("  <!ELEMENT uClass (#PCDATA)>\n");            output.append("  <!ELEMENT uSourceType (#PCDATA)>\n");            output.append("  <!ELEMENT uSourceID (#PCDATA)>\n");            output.append("  <!ELEMENT uStrength (#PCDATA)>\n");            output.append("  <!ELEMENT uDestinationType (#PCDATA)>\n");            output.append("  <!ELEMENT uDestinationID (#PCDATA)>\n");            output.append("  <!ELEMENT uProperties (uPropertiesClass,uValueClass,uPropertiesType,uPropertiesValue+)>\n");            output.append("  <!ELEMENT uPropertiesClass (#PCDATA)>\n");            output.append("  <!ELEMENT uPropertiesValueClass (#PCDATA)>\n");            output.append("  <!ELEMENT uPropertiesType (#PCDATA)>\n");            output.append("  <!ELEMENT uPropertiesValue (#PCDATA)>\n");            output.append("  <!ELEMENT page (#PCDATA)>\n");            output.append("]>\n");            output.append("\n");            output.append("<dataObject>\n");        }        output.append("<graph>\n");        output.append("\t<graphClass>").append("MemGraph").append("</graphClass>\n");        output.append("\t<graphName>").append(this.name).append("</graphName>\n");        Property[] graphProperty = this.getProperty();        if (graphProperty != null) {            for (int i = 0; i < graphProperty.length; ++i) {                output.append("\t<gProperties>\n");                output.append("\t\t<gClass>").append("Basic").append("</gClass>\n");                output.append("\t\t<gValueClass>").append(graphProperty[i].getPropertyClass().getName()).append("</gValueClass>\n");                output.append("\t\t<gType>").append(escapeXML(graphProperty[i].getType())).append("</gType>\n");                Object[] values = graphProperty[i].getValue();                if (values != null) {                    for (int j = 0; j < values.length; ++j) {                        output.append("\t\t<gValue>");                        output.append(escapeXML(PropertyTypeRegister.newInstance().getFactory(graphProperty[i].getPropertyClass()).exportToString(values[j], this)));                        output.append("</gValue>\n");                    }                }                output.append("\t</gProperties>\n");            }        }        PathSet[] pathSet = this.getPathSet();        if (pathSet != null) {            for (int i = 0; i < pathSet.length; ++i) {                output.append("\t<pathSet>\n");                Path[] paths = pathSet[i].getPath();                for (int j = 0; j < paths.length; ++j) {                    output.append("\t\t<path>\n");                    Actor[] actor = paths[j].getPath();                    for (int k = 0; k < actor.length; ++k) {                        output.append("\t\t\t<actor>\n");                        output.append("\t\t\t\t<actorType>").append(actor[k].getType()).append("</actorType>\n");                        output.append("\t\t\t\t<actorID>").append(escapeXML(actor[k].getID())).append("</actorID>\n");                        output.append("\t\t\t</actor>\n");                    }                    output.append("\t\t</path>\n");                }                output.append("\t</pathSet>\n");            }        }        Actor[] user = this.getActor();        if(user != null){        for (int count = 0; count < user.length; ++count) {            Actor u = user[count];            output.append("\t<user>\n");            output.append("\t\t<userClass>").append(u.getType()).append("</userClass>\n");            output.append("\t\t<ID>").append(escapeXML(u.getID())).append("</ID>").append("\n");            if (!isInnerGraph) {                Property[] props = u.getProperty();                if (props != null) {                    for (int i = 0; i < props.length; ++i) {                        output.append("\t\t<properties>\n");                        output.append("\t\t\t<propertiesClass>").append("Basic").append("</propertiesClass>\n");                        output.append("\t\t\t<valueClass>").append(props[i].getPropertyClass().getName()).append("</valueClass>\n");                        output.append("\t\t\t").append("<type>").append(escapeXML(props[i].getType())).append("</type>\n");                        Object[] values = props[i].getValue();                        if (values != null) {                            for (int j = 0; j < values.length; ++j) {                                output.append("\t\t\t<value>");                                output.append(escapeXML(PropertyTypeRegister.newInstance().getFactory(props[i].getPropertyClass()).exportToString(values[j], this)));                                output.append("</value>\n");                            }                        }                        output.append("\t\t</properties>\n");                    }                }                Page[] pages = u.getPage();                if (pages != null) {                    for (int i = 0; i < pages.length; ++i) {                        output.append("\t\t<page>").append(escapeXML(pages[i].getID())).append("</page>\n");                    }                }            }            output.append("\t</user>\n");        }        }        Link[] userLinks = this.getLink();        if (userLinks != null) {            for (int i = 0; i < userLinks.length; ++i) {                output.append("\t<userLink>\n");                output.append("\t\t<uClass>").append(escapeXML(userLinks[i].getType())).append("</uClass>\n");                output.append("\t\t<uStrength>").append(Double.toString(userLinks[i].getStrength())).append("</uStrength>\n");                output.append("\t\t<uSourceType>").append(userLinks[i].getSource().getType()).append("</uSourceType>\n");                output.append("\t\t<uSourceID>").append(escapeXML(userLinks[i].getSource().getID())).append("</uSourceID>\n");                output.append("\t\t<uDestinationType>").append(userLinks[i].getDestination().getType()).append("</uDestinationType>\n");                output.append("\t\t<uDestinationID>").append(escapeXML(userLinks[i].getDestination().getID())).append("</uDestinationID>\n");                if (!isInnerGraph) {                    Property[] propertiesArray = userLinks[i].getProperty();                    if (propertiesArray != null) {                        for (int j = 0; j < propertiesArray.length; ++j) {                            output.append("\t\t<uProperties>\n");                            output.append("\t\t\t<uPropertiesClass>Basic</uPropertiesClass>\n");                            output.append("\t\t\t<uValueClass>" + propertiesArray[j].getPropertyClass().getName() + "</uValueClass>\n");                            output.append("\t\t\t<uPropertiesType>" + escapeXML(propertiesArray[j].getType()) + "</uPropertiesType>\n");                            Object[] values = propertiesArray[j].getValue();                            if (values != null) {                                for (int k = 0; k < values.length; ++k) {                                    output.append("\t\t\t<uPropertiesValue>");                                    output.append(escapeXML(PropertyTypeRegister.newInstance().getFactory(propertiesArray[j].getPropertyClass()).exportToString(values[k], this)));                                    output.append("</uPropertiesValue>\n");                                }                            }                            output.append("\t\t</uProperties>\n");                        }                    }                }                output.append("\t</userLink>\n");            }        }        for (Graph i : children) {            ((MemGraph) i).outputXML(output, true);        }        output.append("</graph>\n");        if(!isInnerGraph){            output.append("</dataObject>\n");        }    }    @Override    public Actor[] getActor() {        Vector<Actor> ret = new Vector<Actor>();        java.util.Iterator<HashMap<String, Actor>> it = actor.values().iterator();        while (it.hasNext()) {            ret.addAll(it.next().values());        }        return ret.toArray(new Actor[]{});    }    //    public void transfer(MemGraph mG){    //        user = new java.util.HashMap<String,User>();    //        User[] mgUser = mG.getUser();    //        for(int i=0;i<mgUser.length;++i){    //            BasicUser u = new BasicUser(mgUser[i].getID());    //            u.load((BasicUser)mgUser[i]);    //            user.put(u.getID(),u);    //        }    //        artist = mG.artist;    //        userLinks = mG.userLinks;    //        artistLinks = mG.artistLinks;    //        algorithm = mG.algorithm;    //        @Override    public Link[] getLinkBySource(String type, Actor source) {        if (links.containsKey(type) && links.get(type).containsKey(source.getType()) && (links.get(type).get(source.getType()).containsKey(source.getID()))) {            return links.get(type).get(source.getType()).get(source.getID()).toArray(new Link[]{});        } else {            return null;        }    }    @Override    public Link[] getLinkByDestination(String type, Actor dest) {        if (invertedLinks.containsKey(type) && invertedLinks.get(type).containsKey(dest.getType()) && (invertedLinks.get(type).get(dest.getType()).containsKey(dest.getID()))) {            return invertedLinks.get(type).get(dest.getType()).get(dest.getID()).toArray(new Link[]{});        } else {            return null;        }    }    @Override    public Link[] getLink(String type, Actor source, Actor dest) {        if (links.containsKey(type) && links.get(type).containsKey(source.getType()) && links.get(type).get(source.getType()).containsKey(source.getID())) {            Vector<Link> base = links.get(type).get(source.getType()).get(source.getID());            Vector<Link> ret = new Vector<Link>();            for (int i = 0; i < base.size(); ++i) {                if (base.get(i).getDestination().equals(dest)) {                    ret.add(base.get(i));                }            }            if (ret.size() > 0) {                return ret.toArray(new Link[]{});            } else {                return null;            }        } else {            return null;        }    }    @Override    public Link[] getLink() {        Vector<Link> ret = new Vector<Link>();        java.util.Iterator<HashMap<String, HashMap<String, Vector<Link>>>> it = links.values().iterator();        while (it.hasNext()) {            java.util.Iterator<HashMap<String, Vector<Link>>> type = it.next().values().iterator();            while (type.hasNext()) {                java.util.Iterator<Vector<Link>> entry = type.next().values().iterator();                while (entry.hasNext()) {                    ret.addAll(entry.next());                }            }        }        if (ret.size() > 0) {            return ret.toArray(new Link[]{});        } else {            return null;        }    }    @Override    public Link[] getLink(String type) {        if (links.containsKey(type)) {            java.util.Iterator<HashMap<String, Vector<Link>>> typeLevel = links.get(type).values().iterator();            Vector<Link> ret = new Vector<Link>();            while (typeLevel.hasNext()) {                java.util.Iterator<Vector<Link>> idLevel = typeLevel.next().values().iterator();                while (idLevel.hasNext()) {                    ret.addAll(idLevel.next());                }            }            return ret.toArray(new Link[]{});        } else {            return null;        }    }    @Override    public void remove(Actor u) {        HashMap<String, Actor> a = actor.get(u.getType());        a.remove(u.getID());        java.util.Iterator<String> sourceLinkType = links.keySet().iterator();        java.util.Iterator<String> destLinkType = invertedLinks.keySet().iterator();        Vector<String> linkSourceType = new Vector<String>();        Vector<String> linkDestType = new Vector<String>();        Vector<String> sourceIDs = new Vector<String>();        Vector<String> destIDs = new Vector<String>();        Vector<String> sourceTypes = new Vector<String>();        Vector<String> destTypes = new Vector<String>();        //        // Remove indexed-by-source links where id is source        // identify all vectors/types for inverted-indexed links        //        while (sourceLinkType.hasNext()) {            String sourceLinkKey = sourceLinkType.next();            if (links.get(sourceLinkKey).containsKey(u.getType()) && (links.get(sourceLinkKey).get(u.getType()).containsKey(u.getID()))) {                HashMap<String, Vector<Link>> forward = links.get(sourceLinkKey).get(u.getType());                Vector<Link> vectForward = forward.get(u.getID());                for (int i = 0; i < vectForward.size(); ++i) {                    //                    System.out.println("Forward: " + key + " - "+ vectForward.get(i).getDestination().getID());                    linkDestType.add(sourceLinkKey);                    destTypes.add(vectForward.get(i).getDestination().getType());                    destIDs.add(vectForward.get(i).getDestination().getID());                }                links.get(sourceLinkKey).get(u.getType()).remove(u.getID());            }        }        //        // Remove indexed-by-destination links where id is source        // identify all vector/types for source-indexed links        //        while (destLinkType.hasNext()) {            String key = destLinkType.next();            if ((invertedLinks.get(key).containsKey(u.getType())) && (invertedLinks.get(key).get(u.getType()).containsKey(u.getID()))) {                HashMap<String, Vector<Link>> backward = invertedLinks.get(key).get(u.getType());                Vector<Link> vectBackward = backward.get(u.getID());                for (int i = 0; i < vectBackward.size(); ++i) {                    //                    System.out.println("Backward: "+key + " - "+ vectBackward.get(i).getSource().getID());                    linkSourceType.add(key);                    sourceTypes.add(vectBackward.get(i).getSource().getType());                    sourceIDs.add(vectBackward.get(i).getSource().getID());                }                invertedLinks.get(key).get(u.getType()).remove(u.getID());            }        }        //        // Remove all destination-indexed links with this actor as source        //        for (int i = 0; i < destIDs.size(); ++i) {            HashMap<String, Vector<Link>> map = invertedLinks.get(linkDestType.get(i)).get(destTypes.get(i));            java.util.Iterator<Link> list = map.get(destIDs.get(i)).iterator();            while (list.hasNext()) {                Link l = list.next();                if (l.getSource().equals(u)) {                    list.remove();                }            }        }        //        // Remove all source-indexed links with this actor as destination        //        for (int i = 0; i < sourceIDs.size(); ++i) {            String type = sourceTypes.get(i);            HashMap<String, Vector<Link>> map = links.get(linkSourceType.get(i)).get(sourceTypes.get(i));            java.util.Iterator<Link> list = map.get(sourceIDs.get(i)).iterator();            while (list.hasNext()) {                Link l = list.next();                if (l.getDestination().equals(u)) {                    list.remove();                }            }        }    }    /*     *     * Remove a link.  Each link is listed twice - by source and by destination     */    public void remove(Link ul) {        String type = ul.getType();        String source = ul.getSource().getID();        String destination = ul.getDestination().getID();        // remove source        java.util.Iterator<Link> it = links.get(type).get(ul.getSource().getType()).get(ul.getSource().getID()).iterator();        while (it.hasNext()) {            if (it.next().getDestination().equals(ul.getDestination())) {                it.remove();            }        }        it = invertedLinks.get(type).get(ul.getDestination().getType()).get(ul.getDestination().getID()).iterator();        while (it.hasNext()) {            if (it.next().getSource().equals(ul.getSource())) {                it.remove();            }        }    }    @Override    public Graph[] getSubGraph(Query q) {        return null;    }    @Override    public void setSubGraph(Query q) {    }    @Override    public Property[] getProperty() {        if (properties.size() == 0) {            return null;        } else {            return properties.values().toArray(new Property[]{});        }    }    @Override    public Property getProperty(String type) {        return properties.get(type);    }    @Override    public void add(Property prop) {        properties.put(prop.getType(), prop);    }    @Override    public PathSet[] getPathSet() {        return pathSets.values().toArray(new PathSet[]{});    }    @Override    public void add(PathSet pathSet) {        pathSets.put(pathSet.getType(), pathSet);    }    @Override    public PathSet getPathSet(String id) {        return pathSets.get(id);    }    @Override    public String[] getLinkTypes() {        return links.keySet().toArray(new String[]{});    }    @Override    public String[] getActorTypes() {        return actor.keySet().toArray(new String[]{});    }    @Override    public void setID(String id) {        name = id;    }    @Override    public String getID() {        return name;    }    @Override    public Iterator<Actor> getActorIterator(String type) {        HashMap<String, Actor> map = actor.get(type);        if (map != null) {            java.util.LinkedList<Actor> ret = new java.util.LinkedList<Actor>();            ret.addAll(map.values());            return ret.iterator();        } else {            return null;        }    }    @Override    public void add(Graph uid) {        if (uid instanceof UserIDList) {            mapped = (UserIDList) uid;        } else if (uid == null) {            mapped = null;        }    }    @Override    public void commit() {        ;//intentionally null    }    @Override    public void close() {        if (outs != null) {            try {                System.out.println("Writing Graph");                outputXML(outs, false);                outs.flush();                outs.close();            } catch (IOException ex) {                ex.printStackTrace();            }        }    }    /**     * Set the output stream to serialize into when closed     * @param w target output stream     */    public void setWriter(java.io.Writer w) {        outs = w;    }    /**     * Encode the string so that it is XML safe     * @param base string to encode     * @return escaped string     */    public String escapeXML(String base) {        String ret = base.replaceAll("&", "&amp;");        ret = ret.replaceAll("<", "&lt;");        ret = ret.replaceAll(">", "&gt;");        ret = ret.replaceAll("[^a-zA-Z0-9-!\"#$%&'()*+,./:;<=>?@\\[\\]\\^_`{|}~\\s]", "");        return ret;    }    @Override    public void anonymize() {        Actor[] a = this.getActor();        for (int i = 0; i < a.length; ++i) {            a[i].setID(Integer.toString(i));        }        Link[] l = this.getLink();        this.actor.clear();        this.links.clear();        this.invertedLinks.clear();        for (int i = 0; i < a.length; ++i) {            this.add(a[i]);        }        for (int i = 0; i < l.length; ++i) {            this.add(l[i]);        }    }    @Override    public Graph getParent() {        return parent;    }    @Override    public Graph[] getChildren() {        if (children.size() > 0) {            return children.toArray(new Graph[]{});        } else {            return null;        }    }    @Override    public Graph getChildren(String id) {        java.util.Iterator<Graph> it = children.iterator();        while (it.hasNext()) {            Graph child = it.next();            if (child.getID().contentEquals(id)) {                return child;            }        }        return null;    }    @Override    public void addChild(Graph g) {        children.add(g);    }    @Override    public Graph getSubGraph(Properties props, Set<Actor> actorList) throws Exception {        Graph ret = GraphFactory.newInstance().create(props);        if (actorList != null) {            Iterator<Actor> it = actorList.iterator();            while (it.hasNext()) {                Actor thisActor = it.next();                if ((actor.get(thisActor.getType()) == null) || (actor.get(thisActor.getType()).get(thisActor.getID()) == null)) {                    throw new Exception("Actor " + thisActor.getID() + " of type " + thisActor.getType() + " does not exist in this graph");                }                ret.add(thisActor);//                index.addActor(thisActor, ret);                LinkedList<Link> list = getLinkBySource(thisActor);                Iterator<Link> link = list.iterator();                while (link.hasNext()) {                    Link l = link.next();                    if("true".equalsIgnoreCase(props.getProperty("AddContext"))){                        ret.add(l);                        ret.add(l.getDestination());                    }else if (actorList.contains(l.getDestination())) {                        ret.add(l);                    }                }                                if("true".equalsIgnoreCase(props.getProperty("AddContext"))){                    list = getLinkByDestination(thisActor);                    link = list.iterator();                    while(link.hasNext()){                        Link l = link.next();                        ret.add(l);                        ret.add(l.getDestination());                    }                }            }        }        return ret;    }    protected LinkedList<Link> getLinkBySource(Actor a) {        LinkedList<Link> ret = new LinkedList<Link>();        if (a != null) {            Iterator<String> linkTypes = links.keySet().iterator();            while (linkTypes.hasNext()) {                String type = linkTypes.next();                if (links.get(type).get(a.getType()) != null) {                    Vector<Link> vector = links.get(type).get(a.getType()).get(a.getID());                    if (vector != null) {                        ret.addAll(vector);                    }                }            }        } else {            System.err.println("Actor in getLinkBySource is null");        }        return ret;    }        protected LinkedList<Link> getLinkByDestination(Actor a){       LinkedList<Link> ret = new LinkedList<Link>();         if (a != null) {            Iterator<String> linkTypes = invertedLinks.keySet().iterator();            while (linkTypes.hasNext()) {                String type = linkTypes.next();                if (invertedLinks.get(type).get(a.getType()) != null) {                    Vector<Link> vector = invertedLinks.get(type).get(a.getType()).get(a.getID());                    if (vector != null) {                        ret.addAll(vector);                    }                }            }        } else {            System.err.println("Actor in getLinkBySource is null");        }       return ret;    }    @Override    public Graph[] getGraphs(Pattern pattern) {        if (pattern.matcher(name).matches()) {            return new Graph[]{this};        } else {            LinkedList<Graph> ret = new LinkedList<Graph>();            Iterator<Graph> it = children.iterator();            while (it.hasNext()) {                Graph g = it.next();                Graph[] match = g.getGraphs(pattern);                for (int i = 0; i < match.length; ++i) {                    ret.add(match[i]);                }            }            return ret.toArray(new Graph[]{});        }    }    @Override    public int getActorCount(String type) {        if(actor.get(type)!=null){            return actor.get(type).size();        }else{            return 0;        }    }    @Override    public Parameter[] getParameters() {        return parameter;    }    @Override    public void init(Properties map) {        Properties props = new Properties();        props.setProperty("Type", "java.lang.String");        props.setProperty("Name", "GraphID");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[0] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("GraphID") != null)) {            parameter[0].setValue(map.getProperty("GraphID"));            name = map.getProperty("GraphID");        } else {            parameter[0].setValue("Root");            name = "Root";        }        props.setProperty("Type", "java.io.FileWriter");        props.setProperty("Name", "GraphOutput");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[1] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("GraphOutput") != null)) {            try {                outs = new FileWriter(map.getProperty("GraphOutput"));                parameter[1].setValue(outs);            } catch (IOException ex) {                Logger.getLogger(MemGraph.class.getName()).log(Level.SEVERE, null, ex);                parameter[1].setValue(null);                outs = null;            }        } else {            parameter[1].setValue(null);            outs = null;        }        props.setProperty("Type", "java.lang.Boolean");        props.setProperty("Name", "Compression");        props.setProperty("Class", "Basic");        props.setProperty("Structural", "true");        parameter[2] = DescriptorFactory.newInstance().createParameter(props);        if ((map != null) && (map.getProperty("relation") != null)) {            gzip = Boolean.parseBoolean(map.getProperty("relation"));            parameter[2].setValue(new Boolean(gzip));        } else {            parameter[2].setValue(new Boolean(false));            gzip = false;        }    }}