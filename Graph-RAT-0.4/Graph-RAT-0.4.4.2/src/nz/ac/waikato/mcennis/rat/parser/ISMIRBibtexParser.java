/*
 * 
 * Copyright Daniel McEnnis - see license.txt
 */
package org.mcennis.graphrat.parser;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.mcennis.graphrat.crawler.Crawler;
import org.mcennis.graphrat.graph.Graph;
import org.mcennis.graphrat.actor.Actor;
import org.mcennis.graphrat.actor.ActorFactory;
import org.mcennis.graphrat.link.Link;
import org.mcennis.graphrat.link.LinkFactory;
import nz.ac.waikato.mcennis.rat.graph.page.Page;
import nz.ac.waikato.mcennis.rat.graph.page.PageFactory;

/**
 * This class parses bibtex files generated by a custom group of perl scripts 
 * that take as input the comma seperated files from www.ismir.net, then reads 
 * the xml version of the papers (pdftohtml) to determine which ismir papers 
 * reference which other papers.  These documents have a strict format which 
 * makes for easy parsing.  In particular, unlike traditional bibtex, these 
 * files have a specific order of fields as well as the non-standard fields of 
 * references and file.  IDs are assumed to be integers (not standard), all 
 * fields are encased in double quotes that extend for a single line, and 
 * references are a set of integers seperated by commas.  This script loads this 
 * format into RAT and establishes two modes (types) of actors: Author and 
 * Paper.  There are two relations (kinds) of link: References (Paper to Paper) 
 * and AuthorOf (Author to Paper).  
 *
 * @author Daniel McEnnis
 * 
 */
public class ISMIRBibtexParser implements Parser {

    Graph graph = null;
    String id = "ISMIRBibtexParser";
    /**
     * Parse the modified bibtex file.  The file is modified in that an ordering
     * of the fields is assumed, all listed fields are assumed to be present 
     * (numeric id as identifier, followed by 
     * @param data
     * @throws java.lang.Exception
     */

    public void parse(InputStream data) throws Exception {
        HashMap<Integer, Actor> actors = new HashMap<Integer, Actor>();
        HashMap<Integer, int[]> references = new HashMap<Integer, int[]>();
        Pattern articleP = Pattern.compile("@Article\\{(.*),");
        Pattern authorP = Pattern.compile("author = \"(.*)\",");
        Pattern titleP = Pattern.compile("title = \"(.*)\",");
        Pattern referenceP = Pattern.compile("references = \"(.*)\",");
        Pattern fileP = Pattern.compile("file = \"(.*)\",");
        Pattern typeP = Pattern.compile("type = \"(.*)\",");
        Matcher articleM;
        Matcher authorM;
        Matcher titleM;
        Matcher referenceM;
        Matcher fileM;
        Matcher typeM;
        int id = -1;
        String authorString = "";
        Properties props = new Properties();
        Actor[] authors = null;
        Actor paper = null;

        /*
         * Read every line and parse each bibtex entry.  If fields are not in 
         * the proper order, this system will crash and burn.
         */
        LineNumberReader reader = new LineNumberReader(new InputStreamReader(data));
        String line = reader.readLine();
        while (line != null) {
            articleM = articleP.matcher(line);
            authorM = authorP.matcher(line);
            titleM = titleP.matcher(line);
            referenceM = referenceP.matcher(line);
            fileM = fileP.matcher(line);
            typeM = typeP.matcher(line);

            /*
             *  if this is the opening line of an entry (containing the numeric 
             *  id), parse it, storing the id to be used for the rest of the 
             *  entries.
             */
            if (articleM.matches()) {
                id = Integer.parseInt(articleM.group(1));
            /*
             * if this is the author line, split the authors.  The format is 
             * is specified as the author line in the ismir CSV format.  Authors
             * are in inverse order, first and last name, seperated by semicolons
             * surrounded by white space.  This block seperates out the authors
             * and creates new Author actors for each, adding to the graph and 
             * alsdo storing in an array of actors for later adding to the paper
             * object this bibtex enrty represents. 
             */
            } else if (authorM.matches()) {
                authorString = authorM.group(1);
                String[] authorNames = Pattern.compile("\\s*;\\s*").split(authorString);
                authors = new Actor[authorNames.length];
                for (int i = 0; i < authorNames.length; ++i) {
                    Actor author = graph.getActor("Author", authorNames[i]);
                    if (author == null) {
                        props.clear();
                        props.setProperty("ActorClass", "Basic");
                        props.setProperty("ActorType", "Author");
                        props.setProperty("ActorID", authorNames[i]);
                        author = ActorFactory.newInstance().create(props);
                        graph.add(author);
                    }
                    authors[i] = author;
                }
            /*
             * Title is taken verbatim from inside the quotes.  Title is used as
             * the unique id for a Paper actor which is added to the graph.  The
             * actor array (assumed to exist) is then utilized to create the 
             * links between the authors and this paper they authored. 
             */
            } else if (titleM.matches()) {
                props.clear();
                props.setProperty("ActorClass", "Basic");
                props.setProperty("ActorType", "Paper");
                props.setProperty("ActorID", titleM.group(1));
                paper = ActorFactory.newInstance().create(props);
                graph.add(paper);
                actors.put(id, paper);
                for (int i = 0; i < authors.length; ++i) {
                    props.clear();
                    props.setProperty("LinkClass", "Basic");
                    props.setProperty("LinkType", "AuthorOf");
                    Link authorOf = LinkFactory.newInstance().create(props);
                    authorOf.set(authors[i], 1.0, paper);
                    graph.add(authorOf);
                }
                authors = null;
            /*
             * Since many are forward references, this creates a new int[] that
             * contains the contents of the references line for later processing
             */
            } else if (referenceM.matches()) {
                String values = referenceM.group(1);
                int[] ref = new int[]
                   
                   {};
                String[] referencesString = Pattern.compile(",").split(values);
                if ((referencesString != null) && (referencesString.length > 0) && (!referencesString[0].contentEquals(""))) {
                    ref = new int[referencesString.length];
                    for (int i = 0; i < referencesString.length; ++i) {
                        ref[i] = Integer.parseInt(referencesString[i]);
                    }
                    references.put(id, ref);
                }

            /*
             * This is the remote location of the file the Paper object is 
             * representing, stored as a page object for future analysis.
             */
            } else if (fileM.matches()) {
                props.clear();
                props.setProperty("PageType", "Basic");
                props.setProperty("PageID", fileM.group(1));
                Page file = PageFactory.newInstance().create(props);
                paper.add(file);
            /*
             * This is the class of paper - a property of the Paper actor.
             */
            } else if (typeM.matches()) {
                props.clear();
                props.setProperty("PropertyType", "Basic");
                props.setProperty("PropertyID", "Type");
                Property property = PropertyFactory.newInstance().create(props);
                property.add(typeM.group(1));
                paper.add(property);
            }
            line = reader.readLine();
        }// while(line != null)

        /*
         * Now that all the papers have been created, link the papers by their 
         * references.   
         */
        Iterator<Integer> it = references.keySet().iterator();
        while (it.hasNext()) {
            int sourceID = it.next();
            int[] refList = references.get(sourceID);
            for (int i = 0; i <
                    refList.length; ++i) {
                props.clear();
                props.setProperty("LinkClass", "Basic");
                props.setProperty("LinkType", "Reference");
                Link refLink = LinkFactory.newInstance().create(props);
                Actor source = actors.get(sourceID);
                if(source == null){
                    System.err.println("Source "+sourceID+" does not exist");
                }
                Actor dest = actors.get(refList[i]);
                if(dest == null){
                    System.err.println("Dest "+refList[i]+" does not exist");
                }
                refLink.set(source, 1.0, dest);
                graph.add(refLink);
            }

        }
    }

    /**
     * Identical to parse - no spidering is done
     * @param data data to be parsed
     * @param crawler ignored
     * @throws java.lang.Exception
     */
    public void parse(InputStream data, Crawler crawler) throws Exception {
        parse(data);
    }

    @Override
    public Parser duplicate() {
        ISMIRBibtexParser ret = new ISMIRBibtexParser();
        ret.graph = graph;
        return ret;
    }

    @Override
    public ParsedObject get() {
        return graph;
    }

    @Override
    public void set(ParsedObject o) {
        if (o instanceof Graph) {
            graph = (Graph) o;
        }
    }

    public void setName(String name) {
        id = name;
    }

    public String getName() {
        return id;
    }
}
